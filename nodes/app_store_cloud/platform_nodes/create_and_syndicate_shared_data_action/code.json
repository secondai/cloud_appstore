{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "63c8bfa5-289b-4d8b-b8f5-6e8908fd1ac2",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // INPUT: {\n      //   type: 'create_and_syndicate_data:Qmdsfkjsl..',\n      //   data: {\n      //     sharedNode: Node,\n      //     permissionsNode: Node\n      //     syndicateToNode: Node\n      //   }\n      // }\n    \n      let {\n        sharedNode,\n        permissionsNode,\n        syndicateToNode\n      } = INPUT.data;\n    \n    \n      let requestCache = await universe.getRequestCache();\n      \n      let InternalUserNode;\n      try {\n        InternalUserNode = requestCache.keyvalue.InternalUserNode;\n      }catch(err){\n        console.error('Missing InternalUserNode', err);\n      }\n      if(!InternalUserNode){\n        // Forgot to identify_via_token beforehand \n        console.error('Missing InternalUserNode for create_and_syndicate action');\n        throw \"Missing InternalUserNode for create_and_syndicate action\";\n        return false;\n      }\n      \n      universe.console.log('Starting create_and_syndicate');\n      \n      // Check author matches myself (private_identity) \n      // - also used for getting our own identity \n      // - TODO \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      // let myPublicKey = MyPrivateIdentity.data.public;\n      // let newChallenge = universe.uuidv4();\n      \n      // Create new temp_shared_node \n      // - get _id of new Node (used in signature) \n      let tmpNodeData = {\n        //nodeId:  // root level? TODO: find put in correct folder? \n        name: universe.uuidv4(),\n        type: \"tmp_shared_node:Qmsdfkj\",\n        data: {\n        }\n      }\n      let savedTmpNode = await universe.newNode(tmpNodeData);\n      \n      console.log('savedTmpNode:', savedTmpNode, savedTmpNode._id);\n      \n      // sourceId is the path back to the node \n      // - \"type:location\" i.e. \"idtestid:sub@nick:internalIdhere\"\n      // - depends on the identity (public/private,etc.) \n      let sourceType;\n      switch(MyPrivateIdentity.data.identity.split(':')[0]){\n        case 'id':\n          sourceType = 'idid'; // normal public identity, normal internal id, the \"ideal\" situation \n          break;\n        case 'idtest':\n          sourceType = 'idtestid';\n          break;\n        default:\n          // unexpected! \n          console.error('Invalid ID type!, missing id or idtest of MyPrivateNode.data.identity');\n          return false;\n          break;\n      }\n      let sourceId = [sourceType, ':', MyPrivateIdentity.data.identity.split(':')[1], ':', savedTmpNode._id].join('')\n      let sharedNodeData = {\n        _id: sourceId, // GLOBAL id (\"type\":\"address\"), \"idtestid:sub@nick:internalId\" \n        name: universe.uuidv4(),\n        type: sharedNode.type,\n        data: sharedNode.data,\n        v: sharedNode.data.v || 1, // version\n        signer: MyPrivateIdentity.data.identity // \"idtest:nick\"\n      }\n      \n      // Sign stringify({_id, type, data})\n      let stringToSign = JSON.stringify(sharedNodeData);\n      let SignedNode = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'sign',\n          options: {\n            stringToSign\n          }\n        }\n      });\n      \n      let result = SignedNode.data; // base64-encoded string signature \n      \n      // Add signature to shared_node.data.signature \n      sharedNodeData.sig = result; // base64-encoded string \n      \n      // Add permissions node (save whatever was sent in) \n      // - permissions are checked in action \"search_shared_data\"\n      //   - the resulting \"syndication_permissions_ugly\" has the matching to use for access requests \n      // - TODO: verify incoming permissions \n      // - TODO: internal-user permissions (using external for now?) \n      let newPermisionsNode = permissionsNode\n      if(permissionsNode.type.indexOf('syndication_permissions:') !== 0){\n        console.error('Invalid permissionsNode supplied'); \n        return false;\n      } else {\n        // Check validity of permissionsNode \n        let lodashQueries = [];\n        for(let rule of permissionsNode.data.rules){\n          let matchObj;\n          switch(rule.type.split(':')[0]){\n              \n            case 'allow_group':\n                \n              matchObj = {\n                \"data.Identity.nodes\": {\n                  $elemMatch: {\n                    type: 'identity_attributes:Qmdslfkjoi23f88f',\n                    [\"data.\" + rule.data.groupKey]: true\n                  }\n                }\n              };\n              lodashQueries.push(matchObj);\n              break;\n            \n            \n            case 'internal_private': // internal_private:Qm3289f0h23\n            \n              console.log('CHECKING internal_private:Qm3289f0h23');\n              \n              matchObj = {\n                \"data.Identity.nodes\": {\n                  $elemMatch: {\n                    type: {\n                      $like: 'internal_user:'\n                    },\n                    [\"data.uuid\"]: InternalUserNode.data.uuid\n                  }\n                }\n              };\n              lodashQueries.push(matchObj);\n              \n              break;\n            \n            \n            default:\n              console.error('Invalid permissionsNode rule type (only allow_groups allowed):', rule.type);\n              continue;\n          }\n        }\n        \n        // Save \"pretty\" read permissions node \n        permissionsNode.nodeId = savedTmpNode._id;\n        let savedPermissionsNode = await universe.newNode(permissionsNode);\n        \n        // Save \"ugly\" permissions node (for actual processing) \n        let newUglyPermissionsNode = {\n          nodeId: savedTmpNode._id,\n          type: 'syndication_permissions_ugly:Qm2398h9sdhfcbvc23',\n          data: {\n            rules: [{\n              type: 'lodash_query:Qmsdfj902932',\n              data: JSON.stringify(lodashQueries.length > 1 ? {$and:lodashQueries}:lodashQueries[0])\n            }]\n          }\n        }\n        \n        let savedUglyPermissionsNode = await universe.newNode(newUglyPermissionsNode);\n        \n        \n        // Create internal write permissions node \n        // - writes only allowed by same internal user! (TODO: or admin) \n        let lodashQueriesWrite = [];\n        let newPermisionsNodeWrite = {\n          type: 'write_permissions:Qm230f9j2f2323fdfg',\n          data: {\n            rules: []\n          }\n        }\n        let matchObjWrite;\n        matchObjWrite = {\n          \"data.Identity.nodes\": {\n            $elemMatch: {\n              type: {\n                $like: 'internal_user:'\n              },\n              [\"data.uuid\"]: InternalUserNode.data.uuid\n            }\n          }\n        };\n        lodashQueriesWrite.push(matchObjWrite);\n        \n        // Save \"pretty\" write permissions node \n        newPermisionsNodeWrite.nodeId = savedTmpNode._id;\n        let savedPermissionsWriteNode = await universe.newNode(newPermisionsNodeWrite);\n        \n        // Save \"ugly\" write permissions node (for actual processing) \n        let newUglyPermissionsWriteNode = {\n          nodeId: savedTmpNode._id,\n          type: 'write_permissions_ugly:Qm283982hf293h',\n          data: {\n            rules: [{\n              type: 'lodash_query:Qmsdfj902932',\n              data: JSON.stringify(lodashQueriesWrite.length > 1 ? {$and:lodashQueriesWrite}:lodashQueriesWrite[0])\n            }]\n          }\n        }\n        \n        let savedUglyPermissionsWriteNode = await universe.newNode(newUglyPermissionsWriteNode);\n        \n        \n        // Save blank \"syndicated_to\" node \n        let blankSyndicatedToNode = {\n          nodeId: savedTmpNode._id,\n          type: 'syndicated_to:Qmf3289h89f32',\n          data: {\n            seconds: {}\n          }\n        }\n        \n        let savedSyndicatedToNode = await universe.newNode(blankSyndicatedToNode);\n        \n      }\n      \n      // Update type to shared_node \n      // - update entire node locally \n      savedTmpNode.type = 'shared_node:Qmsdfjsdlfsj'; // not \"tmp_shared_node\" anymore \n      savedTmpNode.data = sharedNodeData;\n      savedTmpNode = await universe.updateNode(savedTmpNode);\n      \n      \n      // Run syndicateTo (\"push\" sharing) \n      // - TODO: figure out who I'm sharing to (match the \"allow_groups\" rules) \n      // - could have defaults here? \n      // - passed-in idenitities to push to (\"idtest:x@y\") \n      // let SyndicatedResult = await universe.loadAndRunCapability('Syndicate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'everything', // or 'single' (with corresponding options) if syndicating a single new piece of data \n      //     options: {\n            \n      //     }\n      //   }\n      // });\n      \n      // NOT waiting for syndication to complete!\n      // - just triggering it \n      // - TODO: trigger via Job, instead of this way? \n      console.log('Testing Syndication after adding (single)');\n      universe.loadAndRunCapability('Syndicate',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'single', // or 'single' (with corresponding options) if syndicating a single new piece of data \n          options: {\n            type: 'internal_node_id:Qmsdf23lf09j23',\n            data: {\n              nodeId: savedTmpNode._id\n            }\n          }\n        }\n      });\n      \n      \n      \n      \n      universe.console.log('--Returning create_and_syndicate--');\n      \n      return resolve(savedTmpNode);\n      \n      \n      \n    }catch(err){\n      console.error('FAILED create_and_syndicate',err);\n      \n      return resolve({\n        // savedNode\n        type: 'error:..',\n        data: {\n          msg: 'Failed create_and_syndicate',\n          INPUT,\n          error: true,\n          err: err\n        }\n      });\n      // resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"
  }
}