{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "8a1aec75-e403-4e69-84ad-da2fa3652758",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: View Identity Route (backend) --');\n      \n      var StellarSdk = universe.require('stellar-sdk');\n      var crypto = universe.require('crypto');\n        \n      let page = {};\n      \n      // Load address and ipfs data \n      \n      var horizonPossible = {\n        public: {\n          name: 'PubNet',\n          address: 'https://horizon.stellar.org',\n          network: 'public'\n        },\n        test: {\n          name: 'TestNet',\n          address: 'https://horizon-testnet.stellar.org',\n          network: 'test'\n        }\n      };\n      \n      // load Route\n      var routeFullPath = INPUT.data.req.path.substring(5);\n      \n      const { URL } = universe.require('url');\n      var parser = new URL(routeFullPath);\n        \n      try {\n        var protocol = parser.protocol;\n        switch(protocol){\n          case 'id:':\n          case 'idtest:':\n          case 'second:':\n            parser.protocol = 'http:';\n            break;\n          \n          default:\n            page = \"Invalid protocol. please use id:// or idtest:// or second://\"\n            throw \"invalid protocol\"\n        }\n        \n        var baseIdentity = parser.host;\n        var subname = parser.username || '';\n        var password = parser.password.length ? parser.password : null;\n        var routePath = parser.pathname ? parser.pathname.slice(1) : '';\n        \n        console.log('Parsed route:', {baseIdentity, subname, password, routePath});\n      \n    \n        var stellarServer;\n      \n        switch(protocol){\n          case 'id:':\n            StellarSdk.Network.usePublicNetwork();\n            stellarServer = new StellarSdk.Server(horizonPossible['public'].address);\n            break;\n          case 'idtest:':\n            StellarSdk.Network.useTestNetwork();\n            stellarServer = new StellarSdk.Server(horizonPossible['test'].address);\n            break;\n          case 'second:':\n            StellarSdk.Network.useTestNetwork();\n            stellarServer = new StellarSdk.Server(horizonPossible['test'].address); // TODO: change!\n            break;\n          case 'secondtest:':\n            StellarSdk.Network.useTestNetwork();\n            stellarServer = new StellarSdk.Server(horizonPossible['test'].address); // TODO: change!\n            break;\n          default:\n            console.error('Invalid protocol');\n            throw \"invalid protocol\"\n        }\n        \n        console.log('stellarServer', stellarServer);\n        \n        var baseIdentity = baseIdentity.normalize('NFKC').toLowerCase();\n        \n        console.log('baseIdentity:', baseIdentity);\n        \n        var usernameSeed = crypto.createHash('sha256').update(baseIdentity).digest(); //returns a buffer\n        // NFK\n        console.log('usernameSeed', usernameSeed);\n        \n        var pairForIdentity = StellarSdk.Keypair.fromRawEd25519Seed(usernameSeed);\n        \n        console.log('pairForIdentity', pairForIdentity);\n        \n        console.log('Loading identity');\n        \n        let identityAccount = await stellarServer.loadAccount(pairForIdentity.publicKey())\n      \n        console.log('Identity loaded');\n        \n        console.log('identityAccount:', identityAccount);\n        \n        // var lookupPath = subname + '|' + routePath;\n        // if(password){\n        //   lookupPath = password + '|' + subname + '|' + routePath;\n        //   // lookupPath = await encryptToString(subname + '|' + routePath, password+routePath)\n        // }\n        // var lookupPath = '/' + routePath;\n              \n        // route path ALWAYS starts with a slash \n        // - reserving non-slash for zone-like files \n        if(routePath.length == 0){\n          routePath = '/';\n        }\n        \n        let lookupPath = subname + '|' + routePath;\n        if(password){\n          lookupPath = password + '|' + subname + '|' + routePath;\n          // lookupPath = await encryptToString(subname + '|' + routePath, password+routePath)\n        }\n        \n        // var lookupPathHash = crypto.createHash('sha256').update(lookupPath).digest('hex'); \n         \n        console.log('lookupPath:', lookupPath); \n        \n        var lookupPathHash = crypto.createHash('sha256').update(lookupPath).digest('hex'); //returns hex string\n      \n        console.log('lookupPathHash', lookupPathHash);\n        \n        console.log('Getting stellar value for key: ' + lookupPathHash);\n        \n        // get the ipfs value \n        let valueIpfsHash = await identityAccount.data({key: lookupPathHash})\n        .then(function(dataValue) {\n          console.log('decoded dataValue (base64):', dataValue); \n          var decoded = Buffer.from(dataValue.value, 'base64').toString('utf8');  \n          return decoded;\n        })\n        .catch(function (err) {\n          console.error('ipfs error', err, err.stack);\n          return null;\n        })\n        \n        \n        console.log('Data Result:', valueIpfsHash);\n        if(!valueIpfsHash){\n          page = 'missing data result';\n          throw 'Missing data result'\n        }\n        \n        // Load IPFS data \n        console.log('valueIpfsHash:', valueIpfsHash);\n        \n        let ipfsResponse = await universe.webrequest('https://ipfs.io/ipfs/' + valueIpfsHash)\n        .catch(function(err){\n          console.error('Failed loading IPFS hash from ipfs.io');\n          console.error(err);\n        })\n        \n        page = ipfsResponse;\n        \n        // var ipfsData = await getIpfsValue(valueIpfsHash);\n        \n        // console.log('ipfsData:', ipfsData);\n        \n        // var dec = ipfsData;\n        // var actualValue = dec;\n        // if(password){\n        //   console.log('had password'); \n        //   dec = await decryptToString(ipfsData, password+routePath);\n        //   console.log('decrypted1:', dec);\n        //   actualValue = await getIpfsValue(dec);\n        //   dec = await decryptToString(actualValue, password+routePath);\n        //   actualValue = dec;\n        // }\n        \n        // console.log('decrypted-same:', dec == actualValue ? true:false, dec, actualValue);\n        \n        \n        // // expecting a Node type to be returned \n        // var nodeData;\n        // try {\n        //   nodeData = JSON.parse(actualValue);\n        // }catch(err){\n        //   console.error('unable to parse nodedata');\n        // }\n        // // document.write(nodeData);\n        // document.write(actualValue);\n        \n        \n        \n      }catch(err){\n        // failed finding route data \n        console.error('Failed search', err);\n      }\n      \n      \n      \n\n      await universe.httpResponse('send', page);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}