{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "8a1aec75-e403-4e69-84ad-da2fa3652758",
    "code": "(()=>{\n  \n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // return image file.ico \n      // - stream from blob storage? \n      // - this could be re-used in a \"fetch file for token\" approach? \n      \n      // INPUT: expressObj\n      \n      // fetch asset_node, \n      let cacheAppId = universe.getParentRoot(SELF)._id;\n      let cache = ['favicons', cacheAppId].join('|');\n      let faviconNodes = await universe.searchMemory({\n        cache,\n        filter: {\n          sqlFilter: {\n            type: 'asset_node:Qm2390fj2f476j',\n            data: {\n              route: 'favicon.ico'\n            }\n          },\n          uFilter: {\n            type: {\n              $like: 'asset_node:'\n            },\n            'data.route': 'favicon.ico'\n          },\n          filterNodes: tmpNodes=>{\n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                if(!universe.sameAppPlatform(SELF, tmpNode)){\n                  return false;\n                }\n                return true;\n              });\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      console.log('Favicons Found:', faviconNodes.length);\n    \n      let idsToWatchForUpdates = faviconNodes.map(node=>node._id);\n      \n      // Start listening for changes to heartbeat nodes \n      // - restart listening on changes\n      \n      // see if watcher already exists\n      if(!universe.globalCache.faviconListener){\n        universe.globalCache.faviconListener = true;\n        universe.eventEmitter.once('node.afterUpdate', function _listener(emitData){\n          universe.globalCache.faviconListener = false; // re-watch (kinda wonky, requires reload after saving?) \n          \n          // updated node is passed is as emitData (use emitData.type, emitData.data, emitData.nodeId, etc. for node contents) \n          // - TODO: only restart certain nodes, if data is updated, etc. \n          \n          if(idsToWatchForUpdates.indexOf(emitData._id) > -1){\n            console.log('---decaching search------!');\n            universe.globalCache.SearchFilters[cache] = null;\n          }\n          \n        })\n      }\n      \n      // Check cache for file \n      // Return file from aws (pipe download?) \n      let faviconUrl = (faviconNodes.length && faviconNodes[0].data) ? faviconNodes[0].data.url:null;\n      if(!faviconUrl){\n        faviconUrl = 'https://api.getasecond.com/favicon.ico'; // bad if we put our own favicon url (infinite loop) \n      }\n\n      // pipe output directly \n      let reply = universe.webrequest(faviconUrl);\n      let res = await universe.httpResponse('res');\n      let req = INPUT.data.req;\n      req.pipe(reply);\n      reply.pipe(res);\n      \n      // , async (err, response, body)=>{\n        \n      //   console.log('GOT FAVICON:', typeof body, response.headers['content-type']);\n      //   // await universe.httpResponse('set', {\n      //   //   'Content-Type': response.headers['content-type'] \n      //   // });\n        \n      //   await universe.httpResponse('type', response.headers['content-type']);\n      //   await universe.httpResponse('send', body);\n        \n      //   return resolve(true);\n      \n      // });\n      \n      // cache favicon \n      \n      \n      return\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}