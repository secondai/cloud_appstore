{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "8a1aec75-e403-4e69-84ad-da2fa3652758",
    "code": "(()=>{\n  \n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      let nodes = [];\n      \n      // nodes = await universe.searchMemory({\n      //   filter: {\n      //     sqlFilter: {\n      //       _id: \"5ae2543ef7aafb0021ae3f6c\"\n      //     },\n      //   }\n      // });\n      \n      let ipfsResult = 'ipfsResult';\n      try {\n        \n        // let torrentBuffer = new Buffer('this is a test message: ' + Date.now(), 'utf8');\n        \n        // console.log('trying TORRENTSTREAM');\n        \n        // var torrentStream = universe.require('torrent-stream');\n        // var createTorrent = universe.require('create-torrent')\n        // var os = universe.require('os');\n        // var DIR = os.tmpdir()+'/torrent-test-poc';\n        \n        // createTorrent(torrentBuffer, function (err, torrent) {\n        //   if(err){\n        //     return console.error('createTorrent ERROR:', err);\n        //   }\n          \n        //   console.log('TORRENT CREATED!');\n        //   console.log(torrent);\n          \n          \n        //   // torrent is Buffer \n        //   var engine = torrentStream(torrent,{\n      \t\t// \tuploads: 3,\n      \t\t// \tconnections: 30,\n      \t\t// \tpath: DIR\n      \t\t// });\n          \n        //   engine.on('ready', function() {\n        //     console.log('TORRENT ENGINE READY');\n            \n        //   \tengine.files.forEach(function(file) {\n        //   \t\tconsole.log('TORRENT filename:', file.name);\n        //   \t\t// var stream = file.createReadStream();\n        //   \t\t// // stream is readable stream to containing the file content\n        //   \t});\n          \t\n        //   });\n          \n        // })\n\n        \n        // console.log('TRYING WebTorrent');\n        // // var WebTorrent = universe.require('webtorrent');\n        // // var client = new WebTorrent();\n        // let buf = new Buffer('this is a test message: ' + Date.now(),'utf8');\n        // buf.name = 'testingname';\n        \n        // universe.WebTorrent.seed(buf, function (torrent) {\n        //   console.log('TORRENT (info hash):', torrent.infoHash)\n        //   console.log('TORRENT (magnet link):', torrent.magnetURI)\n        //   console.log('TORRENT Files:', torrent.files.length)\n          \n        //   // console.log('torrentId (magnet link):', torrent.magnetURI)\n        // })\n        \n        // console.log('CURRENT TORRENTS:', universe.WebTorrent.torrents)\n        \n        \n        \n        console.log('==Testing if IPFS is ready==');\n        \n        let ipfsSyncResult = await universe.loadAndRunCapability('IPFS',{},{\n          type: 'standard_capability_action:0.0.1:local:298j291bs',\n          data: {\n            action: 'sync',\n            options: {\n            }\n          }\n        });\n        \n        \n        // if(universe.IPFS.isReady()){\n      \n        // console.log('==IPFS IS READY==');\n        \n        // ipfsResult = 'ipfs is ready';\n        \n        \n        // // Test pinning\n        // let file1 = new Buffer('testing random ' + universe.uuidv4(),'utf8');\n        // let file2 = new Buffer('testing random ' + universe.uuidv4(),'utf8');\n        // let pinResponse = await universe.IPFS.pin([file1,file2]);\n        // console.log('PINNED', pinResponse.data.hash);\n        // ipfsResult = ['pinned hash!',pinResponse.data.hash || pinResponse.data.hashes.join('|') ].join(':');\n        \n        // // app root-level (old: global-root) \n        // nodes = await universe.searchMemory({\n        //   filter: {\n        //     dataFilter: {\n        //       // nodeId: null // OLD: root-level\n        //       // type: INPUT.type,\n        //       name: 'incoming_route_handler_test',\n        //       type: {\n        //         $like: 'incoming_route_handler:',\n        //       },\n        //       'data.priority': 5\n        //     }\n        //   }\n        // });\n        \n        \n        // Try to pin my own identity (that is stored on Stellar) \n        nodes = await universe.searchMemory({\n          filter: {\n            dataFilter: {\n              // nodeId: null // OLD: root-level\n              // type: INPUT.type,\n              nodeId: null,\n              type: {\n                $like: 'identity_private:'\n              }\n            }\n          }\n        });\n        \n        let connectionNode = nodes[0].nodes.find(node=>{\n          return node.type == 'private_identity_connect_method:0.0.1:local:9081j29h3'\n        });\n        \n        let ExternalIdentityNode = {\n          type: 'external_identity:0.0.1:local:8982f982j92',\n          data: {\n            publicKey: nodes[0].data.public, //: '-----BEGIN PUBLIC KEY-----\\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAI+ArOUlbt1k2G2n5fj0obEn4mpCfYEx\\nvSZy2c/0tv2caC0AYbxZ4vzppGVjxf+L6fythmWRB0vcwyXHy57fm7ECAwEAAQ==\\n-----END PUBLIC KEY-----'\n          },\n          nodes: [{\n            type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn',\n            data: connectionNode.data // method, connection \n          }]\n        };\n        \n        \n        // try {\n        //   console.log('ExternalIdentityNode', JSON.stringify(ExternalIdentityNode,null,2));\n        //   universe.IPFS.ipfs.files.add(new Buffer(JSON.stringify(ExternalIdentityNode),'utf8'))\n        //   .then(result=>{\n        //     console.log('ADD RESULT1:', result);\n        //     let newHash = result[0].hash;\n        //     // Pin \n        //     universe.IPFS.ipfs.pin.add(newHash)\n        //     .then(pinResult=>{\n        //       console.log('PIN RESULT1:', pinResult);\n        //     });\n        //   })\n        // }catch(err){\n        //   console.error(err);\n        // }\n        \n        \n      }catch(err){\n        console.error('failed check:', err);\n      }\n      \n      \n      \n      // console.log('TEST NODES:', nodes.length);\n      \n      // let node = nodes[0];\n      \n      // delete node._id;\n      // node.name = \"testing_this_one_out2\";\n      // node.data.data.__TESTING = 'TEST2';\n      // await universe.newNode(node, true, true);\n      \n      // // rebuilding rebuildMemory\n      // console.log('======rebuilding memrory======');\n      // await universe.rebuildMemory();\n      // console.log('======DONE REBUILDING MEMRORY!======');\n        \n      let page = `\n        <!DOCTYPE html>\n        <html>\n          <head>\n            <meta charset=\"utf-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n            <title>Testing</title>\n            \n            <link rel=\"icon\" href=\"/favicon.ico\" type=\"image/x-icon\">\n            \n            <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css\" />\n            \n            <style>\n              .container {\n                max-width: 960px;\n              }\n            </style>\n            \n          </head>\n          <body>\n            <div class=\"container\">\n              <div class=\"content\">\n                <pre><code>${ipfsResult}</code></pre>\n                <pre><code>${nodes.length}</code></pre>\n                <pre><code>${JSON.stringify(null,null,2)}</code></pre>\n              </div>\n            </div>\n            \n          </body>\n        </html>\n      `;\n\n      await universe.httpResponse('send', page); //page.replace(new RegExp(\"\\\\n\", 'g'), \"\\\\n\"));\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}