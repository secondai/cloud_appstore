{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Accepts shared_node(s) that should be syndicated for someone \n      // - merges with existing \n      // - includes new permissions_ugly with each node (in addition to data) \n      \n      // INPUT.data: \n      // {\n      //   new : [], // new shared_node and permissions for sharing \n      //   update: [], // nodes, by _id of HERE's shared_node (likely stored it myself, or can query via search_shared_data) \n      //   remove: [] // by matching: _id, signer, version \n      // }\n      \n      // TODO: validation and verify signatures \n      // TODO: limit what I'll syndicate for this person (kinda have part of it already) \n      \n      \n      let requestCache = await universe.getRequestCache({});\n      \n      // Get external_identity (auth'd user) \n      let AuthIdentityNode = requestCache.keyvalue.IdentityNode; \n      if(requestCache.keyvalue.ActAsExternalIdentityNode){\n        // Find external_identity_node for this Second \n        // - \"acting as\" \n        AuthIdentityNode = requestCache.keyvalue.ActAsExternalIdentityNode;\n        // - TODO: what about passing in tokens? \n      }\n      \n      if(!AuthIdentityNode || AuthIdentityNode.type.indexOf('external_identity:') !== 0){\n        console.error('Missing AuthIdentityNode');\n        return resolve({\n          error: true,\n          message: 'Missing AuthIdentityNode, expecting from identify_via_token'\n        });\n      }\n      \n      console.log('INPUT:', INPUT);\n      \n      // Add (new shared_node)  \n      for(let newSharedNode of (INPUT.data.add || [])){\n        if(newSharedNode.type != 'shared_node:Qmsdfjsdlfsj'){\n          console.error('Invalid syndication of non-shared-node');\n          continue;\n        }\n        \n        // save shared node \n        // - TODO: validation of everything (signer, data, etc.) \n        if(newSharedNode.data.signer != AuthIdentityNode.data.identity){\n          console.error('INVALID SIGNER for shared_node, not matching AuthIdentityNode', newSharedNode.data.signer, AuthIdentityNode.data.identity);\n          continue;\n        }\n        \n        // expecting permission_ugly to exist under nodes \n        // - nothing else required \n        let permissionsNode = newSharedNode.nodes.find(n=>{\n          return n.type = 'syndication_permissions_ugly:Qm2398h9sdhfcbvc23'\n        });\n        if(!permissionsNode){\n          console.error('Missing syndication_permissions_ugly for shared_node');\n          continue;\n        }\n        \n        let savedNodeNew = await universe.newNode(newSharedNode);\n        \n        let newPermisionsNode = {\n          nodeId: savedNodeNew._id,\n          type: 'syndication_permissions_ugly:Qm2398h9sdhfcbvc23',\n          data: permissionsNode.data\n        }\n        let savedPermissionsNodeNew = await universe.newNode(newPermisionsNode);\n        \n        \n      }\n      \n      // Update (obj: internalId => new Obj to save, including permissions) \n      for(let nodeId of Object.keys((INPUT.data.update || {}))){\n        console.log('To Update:', key);\n      }\n      \n      // Remove (array of internal Ids) \n      for(let nodeId of (INPUT.data.remove || [])){\n        console.log('To Remove:', nodeId);\n      }\n      \n      \n      console.log('Completed syndicating');\n      \n      return resolve({\n        type: 'boolean:Qm...',\n        data: true\n      });\n      \n      // manage_syndication_identity_attributes_builder:Qmddsfj238900\n        \n        \n    }catch(err){\n      console.error(err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "7090f3d5-3b0b-4c8f-9e44-c01ebf7da87f"
  }
}