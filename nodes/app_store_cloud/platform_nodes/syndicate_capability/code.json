{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "18758d2d-4380-4475-b694-15290a223074",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = standard_capability_action:0.0.1:local:298j291bs\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      // actions \n      // - everything: update everything   \n      // - single: syndicate a single piece of data according to the rules \n      // - permissions: update \"group\" permissions that are synced to the Second (not individual data pieces) \n      \n      switch(inputAction){\n        case 'everything':\n        \n          // completely re-run syndication for all posts, updating everything that needs updating \n          // - likely involves a lot of data changes \n          // - also updates the \"permissions\" stored on other Seconds (groupUUid=>rules) \n          \n          // - only syndicating MY data (created by me), not data that I'm syndicating for other identities \n          \n          // Get internal external_identity nodes that we can syndicate data to \n          // - will have necessary nodes \n          let externalIdentities = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null\n              },\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    if(tmpNode.type.indexOf('external_identity:') === 0){\n                      return true;\n                    }\n                    return false;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          console.log('externalIdentities:', externalIdentities.length); \n          \n          // filter to syndication_info \n          let syndicateToExternalNodes = externalIdentities.filter(externalIdentity=>{\n            return (externalIdentity.nodes  || []).find(childNode=>{\n              return childNode.type.indexOf('syndication_info:') === 0;\n            });\n          });\n          \n          console.log('syndicateToExternalNodes:', syndicateToExternalNodes.length); \n          \n            \n          // Get groups \n          let groupNodes = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null\n              },\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    if(tmpNode.type.indexOf('group_for_sharing') === 0){\n                      return true;\n                    }\n                    return false;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          console.log('Groups:', groupNodes.length);\n          \n          // For each Syndication target: \n          // - create a new \"identity_attributes_builder:Qm..\" \n          //   - handles the grouping necessary for individual access permissions \n          //   - extendable to group by id, token, or other attributes \n          for(let syndicationExternalIdentityNode of syndicateToExternalNodes){\n            // iterate over Groups this external_identity is allowed to know about \n            // - misconfiguration here could lead to unaccessible data by your target audience \n            //   - i.e: when you forget to sync a group to a syndicate, but data is only shown to people in that group \n            let rules = [];\n            let groupsSpecified = syndicationExternalIdentityNode.nodes.filter(node=>{\n              return node.type.indexOf('syndication_group:') === 0;\n            });\n            let builderNode = {\n              type: 'identity_attributes_builder:Qmdsfjkh293fhas',\n              data: {\n                rules\n              }\n            }\n            // TODO: sync buildNode with remote Second (specific action for updating identity_attributes_builder) \n          }\n          \n          \n          console.log('Syndication complete');\n          \n          return resolve({\n            type: 'syndication_result:Qmdfkljsflskdjf',\n            data: {\n              syndicated: true\n            }\n          });\n          \n          \n          \n          break;\n        \n        \n        default:\n          console.error('Missing inputAction for capability');\n          return resolve({\n            type: 'error:Qmdsfljk',\n            data: {\n              error: true,\n              message: 'Missing inputAction for capability'\n            }\n          });\n          break;\n      }\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"
  }
}