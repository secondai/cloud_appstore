{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "18758d2d-4380-4475-b694-15290a223074",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = standard_capability_action:0.0.1:local:298j291bs\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      // actions \n      // - everything: update everything   \n      // - single: syndicate a single piece of data according to the rules \n      // - permissions: update \"group\" permissions that are synced to the Second (not individual data pieces) \n      \n      switch(inputAction){\n        case 'everything':\n        \n          // completely re-run syndication for all posts, updating everything that needs updating \n          // - likely involves a lot of data changes \n          // - also updates the \"permissions\" stored on other Seconds (groupUUid=>rules) \n          \n          // - only syndicating MY data (created by me), not data that I'm syndicating for other identities \n          console.log('Syndicating \"everything\"');\n          \n          let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n          let MyPrivateExternalIdentity;\n          let MyPrivateExternalIdentities = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  identity: MyPrivateIdentity.data.identity\n                }\n              }\n            }\n          });\n          if(MyPrivateExternalIdentities.length){\n            MyPrivateExternalIdentity = MyPrivateExternalIdentities[0];\n          } else {\n            console.error('Missing internal MyPrivateExternalIdentity');\n          }\n          \n          // Get internal external_identity nodes that we can syndicate data to \n          // - will have necessary nodes \n          let externalIdentities = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null\n              },\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    if(tmpNode.type.indexOf('external_identity:') === 0){\n                      return true;\n                    }\n                    return false;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          console.log('externalIdentities:', externalIdentities.length); \n          \n          // filter to syndication_info \n          let syndicateToExternalNodes = externalIdentities.filter(externalIdentity=>{\n            return (externalIdentity.nodes  || []).find(childNode=>{\n              return childNode.type.indexOf('syndication_info:') === 0;\n            });\n          });\n          \n          console.log('syndicateToExternalNodes:', syndicateToExternalNodes.length); \n          \n            \n          // Get groups \n          let groupNodes = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null\n              },\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    if(tmpNode.type.indexOf('group_for_sharing') === 0){\n                      return true;\n                    }\n                    return false;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          console.log('Groups:', groupNodes.length);\n          \n          // For each Syndication target: \n          // - create a new \"identity_attributes_builder:Qmdsflj2301113\" \n          //   - handles the grouping necessary for individual access permissions \n          //   - extendable to group by id, token, or other attributes \n          for(let syndicationExternalIdentityNode of syndicateToExternalNodes){\n            // iterate over Groups this external_identity is allowed to know about \n            // - misconfiguration here could lead to unaccessible data by your target audience \n            //   - i.e: when you forget to sync a group to a syndicate, but data is only shown to people in that group \n            let rules = [\n              // {\n              //   match: {...} // underscore-query\n              //   apply: {...} // Object.assign\n              // }\n            ];\n            let groupsSpecified = syndicationExternalIdentityNode.nodes.filter(node=>{\n              return node.type.indexOf('syndication_group:') === 0;\n            });\n            console.log('groupsSpecified:', groupsSpecified.length, syndicationExternalIdentityNode.data.identity);\n            \n            for(let groupInfo of groupsSpecified){\n              let groupNode = groupNodes.find(n=>{\n                return n.data.key == groupInfo.data.groupKey;\n              });\n              // console.log('groupNode specified:', groupNode);\n              if(!groupNode){\n                console.error('Unable to find groupNode:', group.data.groupKey);\n                continue;\n              }\n              for(let filter of groupNode.data.identities){\n                \n                // console.log('identityFilter:', JSON.stringify(filter,null,2));\n                let ruleMatch;\n                let ruleApply;\n                switch(filter.type.split(':')[0]){\n                  case 'identity_range': // implied: \"allow\"\n                    // convert to a regex\n                    \n                    // // how it is built client-side \n                    // if(filter.data.idType == idType){\n                    //   if(filter.data.username == '*' || filter.data.username == username){\n                    //     if((!filter.data.subname && !subname) || (filter.data.subname == '*' || filter.data.subname == subname)){\n                    //       allow = true;\n                    //     }\n                    //   }\n                    // }\n                    \n                    // build line-by-line (instead of creating a big regex?) \n                    // - identity to match: \"idtest:second1\"\n                    let allRules = [];\n                    if(filter.data.username == '*'){\n                      allRules.push({});\n                    } else {\n                      // username/namespace specified \n                      allRules.push({\n                        data: {\n                          identity: {\n                            $like: ':' + filter.data.username\n                          }\n                        }\n                      });\n                      if(filter.data.subname == '*'){\n                        // all subnames allowed \n                        allRules.push({\n                          data: {\n                            identity: {\n                              $regex: /(\\:[a-zA-Z]*\\@)/\n                            }\n                          }\n                        });\n                      } else if(filter.data.subname === ''){\n                        // no subnames allowed \n                        allRules.push({\n                          data: {\n                            identity: {\n                              $not: {\n                                $like: '@'\n                              }\n                            }\n                          }\n                        });\n                      } else {\n                        // subname specified \n                        allRules.push({\n                          data: {\n                            identity: {\n                              $like: ':' + filter.data.subname + '@'\n                            }\n                          }\n                        });\n                      }\n                    }\n                    allRules = universe.lodash.uniqBy(allRules,r=>JSON.stringify(r));\n                    ruleMatch = (allRules.length > 1) ? {$and: allRules} : allRules[0];\n                    \n                    \n                    ruleApply = {};\n                    ruleApply[groupNode.data.key] = true; // 1?\n                    \n                    rules.push({\n                      match: JSON.stringify(ruleMatch),\n                      apply: ruleApply\n                    });\n                    \n                    break;\n                    \n                  default:\n                    console.error('Unsupported groupNode filter type!:', filter.type.split(':')[0]);\n                    break;\n                    \n                }\n              }\n            }\n            \n            rules = universe.lodash.uniqBy(rules,r=>JSON.stringify(r));\n                    \n            let builderNode = {\n              type: 'identity_attributes_builder:Qmdsflj2301113',\n              data: {\n                rules\n              }\n            }\n            \n            // console.log('builderNode', JSON.stringify(builderNode,null,2));\n            console.log('builderNode', syndicationExternalIdentityNode.data.identity);\n            \n            // sync buildNode with remote Second (specific action for updating identity_attributes_builder)\n            if(MyPrivateIdentity.data.identity == syndicationExternalIdentityNode.data.identity){\n              // this is my own external_identity \n              // - save locally, mimicing \"manage_syndication_identity_attributes_builder:Qmddsfj238900\" action \n              console.log('My own private identity!');\n              \n              // should already exist locally (created in createLocal) \n              let previousBuilderNode = MyPrivateExternalIdentity.nodes.find(n=>{\n                return n.type == 'identity_attributes_builder:Qmdsflj2301113';\n              });\n              if(!previousBuilderNode){\n                console.error('Missing previousBuilderNode in MyPrivateIdentity');\n              } else {\n                // update \n                previousBuilderNode.data = builderNode.data;\n                let updatedPreviousBuilderNode = await universe.updateNode(previousBuilderNode);\n                console.log('updatedPreviousBuilderNode'); \n              }\n              \n            } else {\n              // sync builderNode to remote Second using \"manage_syndication_identity_attributes_builder:Qmddsfj238900\" action \n              // - identity_via_token, pass in new builder node \n              \n              console.log('--syncing builderNode for remote second--');\n               \n              // Get connect method\n              let url = syndicationExternalIdentityNode.nodes.find(n=>{\n                return (n.type.split(':')[0] == 'external_identity_connect_method')\n              }).data.connection;\n              \n              let reqData = {\n                type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                data: {\n                  actions: [\n                    \n                    {\n                      matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                      dataForAction: {\n                        type: 'string:...',\n                        data: syndicationExternalIdentityNode.data.token\n                      }\n                    },\n                    \n                    {\n                      matchActionType: 'manage_syndication_identity_attributes_builder:Qmddsfj238900',\n                      dataForAction: builderNode, // identity_attributes_builder:Qmdsflj2301113\n                    }\n                  \n                  ]\n                }\n              }\n              let response;\n              try {\n                response = await universe.webrequest.post({\n                  url,\n                  body: reqData,\n                  json: true\n                });\n              }catch(err){\n                console.error('Failed webrequest for manage_syndication_identity_attributes_builder:', syndicationExternalIdentityNode.data.identity);\n              }\n              \n              // parse response?\n              console.log('Got response for manage_syndication_identity_attributes_builder...Success?').\n              \n              \n            }\n            \n            // testing: save for my local second!\n            // builderNode.nodeId = syndicationExternalIdentityNode._id;\n            // let savedTmpBuilderNode = await universe.newNode(builderNode);\n            // console.log('saved builderNode');\n            \n            \n            \n          }\n          \n          \n          console.log('Syndication complete');\n          \n          return resolve({\n            type: 'syndication_result:Qmdfkljsflskdjf',\n            data: {\n              syndicated: true\n            }\n          });\n          \n          \n          \n          break;\n        \n        \n        default:\n          console.error('Missing inputAction for capability');\n          return resolve({\n            type: 'error:Qmdsfljk',\n            data: {\n              error: true,\n              message: 'Missing inputAction for capability'\n            }\n          });\n          break;\n      }\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"
  }
}