{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "18758d2d-4380-4475-b694-15290a223074",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = standard_capability_action:0.0.1:local:298j291bs\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      // actions \n      // - everything: update everything   \n      // - single: syndicate a single piece of data according to the rules \n      // - permissions: update \"group\" permissions that are synced to the Second (not individual data pieces) \n      \n      switch(inputAction){\n        case 'everything':\n        \n          // completely re-run syndication for all posts, updating everything that needs updating \n          // - likely involves a lot of data changes \n          // - also updates the \"permissions\" stored on other Seconds (groupUUid=>rules) \n          \n          // - only syndicating MY data (created by me), not data that I'm syndicating for other identities \n          console.log('Syndicating \"everything\"');\n          \n          // Get internal external_identity nodes that we can syndicate data to \n          // - will have necessary nodes \n          let externalIdentities = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null\n              },\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    if(tmpNode.type.indexOf('external_identity:') === 0){\n                      return true;\n                    }\n                    return false;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          console.log('externalIdentities:', externalIdentities.length); \n          \n          // filter to syndication_info \n          let syndicateToExternalNodes = externalIdentities.filter(externalIdentity=>{\n            return (externalIdentity.nodes  || []).find(childNode=>{\n              return childNode.type.indexOf('syndication_info:') === 0;\n            });\n          });\n          \n          console.log('syndicateToExternalNodes:', syndicateToExternalNodes.length); \n          \n            \n          // Get groups \n          let groupNodes = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null\n              },\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    if(tmpNode.type.indexOf('group_for_sharing') === 0){\n                      return true;\n                    }\n                    return false;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          console.log('Groups:', groupNodes.length);\n          \n          // For each Syndication target: \n          // - create a new \"identity_attributes_builder:Qmdsflj2301113\" \n          //   - handles the grouping necessary for individual access permissions \n          //   - extendable to group by id, token, or other attributes \n          for(let syndicationExternalIdentityNode of syndicateToExternalNodes){\n            // iterate over Groups this external_identity is allowed to know about \n            // - misconfiguration here could lead to unaccessible data by your target audience \n            //   - i.e: when you forget to sync a group to a syndicate, but data is only shown to people in that group \n            let rules = [\n              // {\n              //   match: {...} // underscore-query\n              //   apply: {...} // Object.assign\n              // }\n            ];\n            let groupsSpecified = syndicationExternalIdentityNode.nodes.filter(node=>{\n              return node.type.indexOf('syndication_group:') === 0;\n            });\n            console.log('groupsSpecified:', groupsSpecified.length, syndicationExternalIdentityNode.data.identity);\n            \n            for(let groupInfo of groupsSpecified){\n              let groupNode = groupNodes.find(n=>{\n                return n.data.key == groupInfo.data.groupKey;\n              });\n              // console.log('groupNode specified:', groupNode);\n              if(!groupNode){\n                console.error('Unable to find groupNode:', group.data.groupKey);\n                continue;\n              }\n              for(let filter of groupNode.data.identities){\n                \n                console.log('identityFilter:', JSON.stringify(filter,null,2));\n                let ruleMatch;\n                let ruleApply;\n                switch(filter.type.split(':')[0]){\n                  case 'identity_range': // implied: \"allow\"\n                    // convert to a regex\n                    \n                    // // how it is built client-side \n                    // if(filter.data.idType == idType){\n                    //   if(filter.data.username == '*' || filter.data.username == username){\n                    //     if((!filter.data.subname && !subname) || (filter.data.subname == '*' || filter.data.subname == subname)){\n                    //       allow = true;\n                    //     }\n                    //   }\n                    // }\n                    \n                    // build line-by-line (instead of creating a big regex?) \n                    // - identity to match: \"idtest:second1\"\n                    let allRules = [];\n                    if(filter.data.username == '*'){\n                      allRules.push({});\n                    } else {\n                      // username/namespace specified \n                      allRules.push({\n                        data: {\n                          identity: {\n                            $like: ':' + filter.data.username\n                          }\n                        }\n                      });\n                      if(filter.data.subname == '*'){\n                        // all subnames allowed \n                        allRules.push({\n                          data: {\n                            identity: {\n                              $regex: /(\\:[a-zA-Z]*\\@)/\n                            }\n                          }\n                        });\n                      } else if(filter.data.subname === ''){\n                        // no subnames allowed \n                        allRules.push({\n                          data: {\n                            identity: {\n                              $not: {\n                                $like: '@'\n                              }\n                            }\n                          }\n                        });\n                      } else {\n                        // subname specified \n                        allRules.push({\n                          data: {\n                            identity: {\n                              $like: ':' + filter.data.subname + '@'\n                            }\n                          }\n                        });\n                      }\n                    }\n                    allRules = universe.lodash.uniqBy(allRules,r=>JSON.stringify(r));\n                    ruleMatch = (allRules.length > 1) ? {$and: allRules} : allRules[0];\n                    \n                    \n                    ruleApply = {};\n                    ruleApply[groupNode.data.key] = true; // 1?\n                    \n                    rules.push({\n                      match: JSON.stringify(ruleMatch),\n                      apply: ruleApply\n                    });\n                    \n                    break;\n                    \n                  default:\n                    console.error('Unsupported groupNode filter type!:', filter.type.split(':')[0]);\n                    break;\n                    \n                }\n              }\n            }\n            \n            rules = universe.lodash.uniqBy(rules,r=>JSON.stringify(r));\n                    \n            let builderNode = {\n              type: 'identity_attributes_builder:Qmdsflj2301113',\n              data: {\n                rules\n              }\n            }\n            \n            // console.log('builderNode', JSON.stringify(builderNode,null,2));\n            console.log('builderNode', syndicationExternalIdentityNode.data.identity);\n            \n            // TODO: sync buildNode with remote Second (specific action for updating identity_attributes_builder) \n            \n            // testing: save for my local second!\n            // builderNode.nodeId = syndicationExternalIdentityNode._id;\n            // let savedTmpBuilderNode = await universe.newNode(builderNode);\n            \n            console.log('saved builderNode');\n            \n          }\n          \n          \n          console.log('Syndication complete');\n          \n          return resolve({\n            type: 'syndication_result:Qmdfkljsflskdjf',\n            data: {\n              syndicated: true\n            }\n          });\n          \n          \n          \n          break;\n        \n        \n        default:\n          console.error('Missing inputAction for capability');\n          return resolve({\n            type: 'error:Qmdsfljk',\n            data: {\n              error: true,\n              message: 'Missing inputAction for capability'\n            }\n          });\n          break;\n      }\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"
  }
}