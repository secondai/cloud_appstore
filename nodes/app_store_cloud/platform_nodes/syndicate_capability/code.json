{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "18758d2d-4380-4475-b694-15290a223074",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = standard_capability_action:0.0.1:local:298j291bs\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      // actions \n      // - everything: update everything   \n      // - single: syndicate a single piece of data according to the rules \n      // - permissions: update \"group\" permissions that are synced to the Second (not individual data pieces) \n      \n          \n      // Get internal external_identity nodes that we can syndicate data to \n      // - will have necessary nodes \n      let externalIdentities = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            nodeId: null\n          },\n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                if(tmpNode.type.indexOf('external_identity:') === 0){\n                  return true;\n                }\n                return false;\n              });\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      console.log('externalIdentities:', externalIdentities.length); \n      \n      // filter to syndication_info \n      let syndicateToExternalNodes = externalIdentities.filter(externalIdentity=>{\n        return (externalIdentity.nodes  || []).find(childNode=>{\n          return childNode.type.indexOf('syndication_info:') === 0;\n        });\n      });\n      \n      console.log('syndicateToExternalNodes:', syndicateToExternalNodes.length); \n      \n        \n      // Get groups \n      let groupNodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            nodeId: null\n          },\n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                if(tmpNode.type.indexOf('group_for_sharing') === 0){\n                  return true;\n                }\n                return false;\n              });\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      console.log('Groups:', groupNodes.length);\n      \n      \n      // start processing input\n      switch(inputAction){\n        case 'permissions':\n        \n          // completely re-run syndication for all posts, updating everything that needs updating \n          // - likely involves a lot of data changes \n          // - also updates the \"permissions\" stored on other Seconds (groupUUid=>rules) \n          \n          // - only syndicating MY data (created by me), not data that I'm syndicating for other identities \n          console.log('Syndicating \"everything\"');\n          \n          let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n          let MyPrivateExternalIdentity;\n          let MyPrivateExternalIdentities = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  identity: MyPrivateIdentity.data.identity\n                }\n              }\n            }\n          });\n          if(MyPrivateExternalIdentities.length){\n            MyPrivateExternalIdentity = MyPrivateExternalIdentities[0];\n          } else {\n            console.error('Missing internal MyPrivateExternalIdentity');\n          }\n          \n          // For each Syndication target: \n          // - create a new \"identity_attributes_builder:Qmdsflj2301113\" \n          //   - handles the grouping necessary for individual access permissions \n          //   - extendable to group by id, token, or other attributes \n          for(let syndicationExternalIdentityNode of syndicateToExternalNodes){\n            // iterate over Groups this external_identity is allowed to know about \n            // - misconfiguration here could lead to unaccessible data by your target audience \n            //   - i.e: when you forget to sync a group to a syndicate, but data is only shown to people in that group \n            let rules = [\n              // {\n              //   match: {...} // underscore-query\n              //   apply: {...} // Object.assign\n              // }\n            ];\n            let groupsSpecified = syndicationExternalIdentityNode.nodes.filter(node=>{\n              return node.type.indexOf('syndication_group:') === 0;\n            });\n            console.log('groupsSpecified:', groupsSpecified.length, syndicationExternalIdentityNode.data.identity);\n            \n            for(let groupInfo of groupsSpecified){\n              let groupNode = groupNodes.find(n=>{\n                return n.data.key == groupInfo.data.groupKey;\n              });\n              // console.log('groupNode specified:', groupNode);\n              if(!groupNode){\n                console.error('Unable to find groupNode:', group.data.groupKey);\n                continue;\n              }\n              for(let filter of groupNode.data.identities){\n                \n                // console.log('identityFilter:', JSON.stringify(filter,null,2));\n                let ruleMatch;\n                let ruleApply;\n                switch(filter.type.split(':')[0]){\n                  case 'identity_range': // implied: \"allow\"\n                    // convert to a regex\n                    \n                    // // how it is built client-side \n                    // if(filter.data.idType == idType){\n                    //   if(filter.data.username == '*' || filter.data.username == username){\n                    //     if((!filter.data.subname && !subname) || (filter.data.subname == '*' || filter.data.subname == subname)){\n                    //       allow = true;\n                    //     }\n                    //   }\n                    // }\n                    \n                    // build line-by-line (instead of creating a big regex?) \n                    // - identity to match: \"idtest:second1\"\n                    let allRules = [];\n                    if(filter.data.username == '*'){\n                      allRules.push({});\n                    } else {\n                      // username/namespace specified \n                      allRules.push({\n                        'data.identity': {\n                          $like: ':' + filter.data.username\n                        }\n                      });\n                      if(filter.data.subname == '*'){\n                        // all subnames allowed \n                        allRules.push({\n                          'data.identity': {\n                            $regex: /(\\:[a-zA-Z\\d-_]*\\@)/\n                          }\n                        });\n                      } else if(filter.data.subname === ''){\n                        // no subnames allowed \n                        allRules.push({\n                          'data.identity': {\n                            $not: {\n                              $like: '@'\n                            }\n                          }\n                        });\n                      } else {\n                        // subname specified \n                        allRules.push({\n                          'data.identity': {\n                            $like: ':' + filter.data.subname + '@'\n                          }\n                        });\n                      }\n                    }\n                    allRules = universe.lodash.uniqBy(allRules,r=>JSON.stringify(r));\n                    ruleMatch = (allRules.length > 1) ? {$and: allRules} : allRules[0];\n                    \n                    \n                    ruleApply = {};\n                    ruleApply[groupNode.data.key] = true; // 1?\n                    \n                    rules.push({\n                      match: JSON.stringify(ruleMatch),\n                      apply: ruleApply\n                    });\n                    \n                    break;\n                    \n                  default:\n                    console.error('Unsupported groupNode filter type!:', filter.type.split(':')[0]);\n                    break;\n                    \n                }\n              }\n            }\n            \n            rules = universe.lodash.uniqBy(rules,r=>JSON.stringify(r));\n                    \n            let builderNode = {\n              type: 'identity_attributes_builder:Qmdsflj2301113',\n              data: {\n                rules\n              }\n            }\n            \n            // console.log('builderNode', JSON.stringify(builderNode,null,2));\n            console.log('builderNode', syndicationExternalIdentityNode.data.identity);\n            \n            // sync buildNode with remote Second (specific action for updating identity_attributes_builder)\n            if(MyPrivateIdentity.data.identity == syndicationExternalIdentityNode.data.identity){\n              // this is my own external_identity \n              // - save locally, mimicing \"manage_syndication_identity_attributes_builder:Qmddsfj238900\" action \n              console.log('My own private identity!');\n              \n              // should already exist locally (created in createLocal) \n              let previousBuilderNode = MyPrivateExternalIdentity.nodes.find(n=>{\n                return n.type == 'identity_attributes_builder:Qmdsflj2301113';\n              });\n              if(!previousBuilderNode){\n                console.error('Missing previousBuilderNode in MyPrivateIdentity');\n              } else {\n                // update \n                previousBuilderNode.data = builderNode.data;\n                let updatedPreviousBuilderNode = await universe.updateNode(previousBuilderNode);\n                console.log('updatedPreviousBuilderNode'); \n              }\n              \n            } else {\n              // sync builderNode to remote Second using \"manage_syndication_identity_attributes_builder:Qmddsfj238900\" action \n              // - identity_via_token, pass in new builder node \n              \n              console.log('--syncing builderNode for remote second--');\n               \n              // Get connect method\n              let url = syndicationExternalIdentityNode.nodes.find(n=>{\n                return (n.type.split(':')[0] == 'external_identity_connect_method')\n              }).data.connection;\n              \n              let reqData = {\n                type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                data: {\n                  actions: [\n                    \n                    {\n                      matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                      dataForAction: {\n                        type: 'string:...',\n                        data: syndicationExternalIdentityNode.data.token\n                      }\n                    },\n                    \n                    {\n                      matchActionType: 'manage_syndication_identity_attributes_builder:Qmddsfj238900',\n                      dataForAction: builderNode, // identity_attributes_builder:Qmdsflj2301113\n                    }\n                  \n                  ]\n                }\n              }\n              let response;\n              try {\n                response = await universe.webrequest.post({\n                  url,\n                  body: reqData,\n                  json: true\n                });\n              }catch(err){\n                console.error('Failed webrequest for manage_syndication_identity_attributes_builder:', syndicationExternalIdentityNode.data.identity);\n              }\n              \n              // parse response?\n              console.log('Got response for manage_syndication_identity_attributes_builder...Success?');\n              \n              \n            }\n            \n            // testing: save for my local second!\n            // builderNode.nodeId = syndicationExternalIdentityNode._id;\n            // let savedTmpBuilderNode = await universe.newNode(builderNode);\n            // console.log('saved builderNode');\n            \n            \n            \n          }\n          \n          \n          console.log('Syndication complete');\n          \n          return resolve({\n            type: 'syndication_result:Qmdfkljsflskdjf',\n            data: {\n              syndicated: true\n            }\n          });\n          \n        \n          break;\n          \n        \n        \n        case 'single':\n          // syndicate a single new shared_node to remote \n          // - only the internal shared_node._id needs to be available; we'll fetch it here \n          // - inputOpts.type == 'internal_node_id:Qmsdf23lf09j23'\n          // - inputOpts.data.nodeId \n          let SingleSharedNodeToSyndicate = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                _id: inputOpts.data.nodeId,\n                type: 'shared_node:Qmsdfjsdlfsj'\n              }\n            }\n          });\n          if(!SingleSharedNodeToSyndicate || !SingleSharedNodeToSyndicate.length){\n            console.error('Unable to find shared_node to syndicate');\n            return resolve({\n              type: 'error:Qm...',\n              data: {\n                error: true,\n                message: 'Unable to find shared_node to syndicate'\n              }\n            });\n          }\n          SingleSharedNodeToSyndicate = SingleSharedNodeToSyndicate[0];\n          \n          // get rules for sharing \n          // - parsed for syndication \n          let permissionsPretty = SingleSharedNodeToSyndicate.nodes.find(n=>{\n            return n.type == 'syndication_permissions:Qmsdfkjsl2fj9vxc';\n          });\n          if(!permissionsPretty){\n            console.error('Unable to find syndication_permissions for shared_node to syndicate');\n            return resolve({\n              type: 'error:Qm...',\n              data: {\n                error: true,\n                message: 'Unable to find syndication_permissions for shared_node to syndicate'\n              }\n            });\n          }\n          \n          // must have permissions_ugly (would have been created/updated already) \n          let permissionsUgly = SingleSharedNodeToSyndicate.nodes.find(n=>{\n            return n.type == 'syndication_permissions_ugly:Qm2398h9sdhfcbvc23';\n          });\n          if(!permissionsUgly){\n            console.error('Unable to find syndication_permissions_ugly for shared_node to syndicate');\n            return resolve({\n              type: 'error:Qm...',\n              data: {\n                error: true,\n                message: 'Unable to find syndication_permissions_ugly for shared_node to syndicate'\n              }\n            });\n          }\n          \n          // get existing syndication information \n          // - updating or adding shared_node? \n          let syndicatedToExisting = SingleSharedNodeToSyndicate.nodes.find(n=>{\n            return n.type == 'syndicated_to:Qmf3289h89f32';\n          });\n          if(!syndicatedToExisting){\n            console.error('Unable to find syndicated_to for shared_node to syndicate');\n            return resolve({\n              type: 'error:Qm...',\n              data: {\n                error: true,\n                message: 'Unable to find syndicated_to for shared_node to syndicate'\n              }\n            });\n          }\n          \n          \n          // Get syndication targets \n          // - see if each syndication target matches for this content \n          \n          // create node we'll send for saving \n          let nodeToSyndicate = {\n            type: 'shared_node:Qmsdfjsdlfsj',\n            data: SingleSharedNodeToSyndicate.data,\n            nodes: [{\n              type: 'syndication_permissions_ugly:Qm2398h9sdhfcbvc23',\n              data: permissionsUgly.data\n            }]\n          }\n          \n          // Iterate over syndication targets to check for matches \n          // - updates local \"syndicatedTo\" node \n          for(let syndicationExternalIdentityNode of syndicateToExternalNodes){\n            \n            // determine if should syndicate \n            // - determine if already syndicated (syndicated_to.data.seconds.[identity]: remoteNodeId) \n            \n            // TODO: handle revoking shared_nodes \n            \n            // get \"syndicate when XYZ\" nodes for external_identity \n            // - view permissions \n            // - content \n            \n            // get nodeId if already syndicated to this remote Second \n            let alreadySyndicatedId = syndicatedToExisting.data.seconds[ syndicationExternalIdentityNode.data.identity ];\n            \n            let syndicateIfNodes = syndicationExternalIdentityNode.nodes.filter(node=>{\n              return node.type.indexOf('syndication_info:Qmsdlfjk23ji') === 0;\n            });\n            console.log('syndicateIfNodes:', syndicateIfNodes.length, syndicationExternalIdentityNode.data.identity);\n            if(!syndicateIfNodes || !syndicateIfNodes.length){\n              console.error('Missing syndication_info for external_identity when trying to syndicate (at least 1 required!)'); \n              continue;\n            }\n            \n            // see if matches for syndicateIfNode \n            // - checks data and identities/permissions (\"when allow_group\" and data is a \"post\") \n            // - any matches (TODO: more complex queries (this group, not this group)) \n            //   - currently provides data, then counts on the remote Second to apply permissions correctly \n            \n            // Identity rules \n            let shouldSyndicate = false;\n            for(let syndicateIfNode of syndicateIfNodes){\n              \n              let syndicatePassed = false;\n              for(let rule of syndicateIfNode.data.identityRules){\n                // simple check for intersection of groups \n                \n                switch(rule.type){\n                  case 'syndicate_group_allowed:Qmf3829hh2398h':\n                    // matches against actual pretty permissions \n                    // console.log('IDENTITY CHECK:', JSON.stringify(permissionsPretty,null,2));\n                    // console.log('IDCHECK2:', JSON.stringify(JSON.parse(rule.data.query),null,2));\n                    let matched = universe.lodash.query([permissionsPretty], JSON.parse(rule.data.query)).length;\n                    if(matched){\n                      syndicatePassed = true;\n                    }\n                    break;\n                    \n                  default:\n                    console.error('Invalid rule for identityRules supplied:', rule.type);\n                    break;\n                }\n                \n              }\n              \n              if(!syndicatePassed){\n                console.log('failed identityRules');\n                continue;\n              }\n              \n              // Data rules \n              for(let rule of syndicateIfNode.data.dataRules){\n                // simple check for intersection of groups \n                \n                switch(rule.type){\n                  case 'data_match_mongolike:Qmf32jsd8222fwea':\n                    // matches against actual pretty permissions \n                    let matched = universe.lodash.query([nodeToSyndicate], JSON.parse(rule.data.query)).length;\n                    if(matched){\n                      syndicatePassed = true;\n                    }\n                    break;\n                    \n                  default:\n                    console.error('Invalid rule for identityRules supplied:', rule.type);\n                    break;\n                }\n                \n              }\n              \n              if(!syndicatePassed){\n                console.log('failed dataRules');\n                continue;\n              }\n              \n              shouldSyndicate = true;\n              \n            }\n            \n            let writeObj = {\n              add: [], // share_node w/ nodes \n              update: {}, // id => shared_node w/ nodes \n              remove: [] // array of ids \n            };\n            let needsWrite = false;\n            \n            if(!shouldSyndicate){\n              console.error('every syndication check failed (not syndicating sharedNode anywhere [probably ok!])');\n              \n              if(alreadySyndicatedId){\n                console.log('remove from syndication!');\n                writeObj.remove.push(alreadySyndicatedId);\n                needsWrite = true;\n              }\n              \n            } else {\n              // expecting syndication \n              console.log('SHOULD SYNDICATE TO:', syndicationExternalIdentityNode.data.identity);\n              try {\n                if(alreadySyndicatedId){\n                  writeObj.update[alreadySyndicatedId] = nodeToSyndicate;\n                  needsWrite = true; // TODO: determine if update is actually necessary \n                } else {\n                  writeObj.add.push(nodeToSyndicate);\n                  needsWrite = true;\n                }\n              }catch(err){\n                console.error('failed shouldSyndicate:', err);\n              }\n              \n            }\n            \n            if(!needsWrite){\n              console.log('No syndication update necessary');\n              continue;\n            }\n            \n            console.log('writeObj', JSON.stringify(writeObj,null,2));\n            \n             // already syndicated? \n             // - update if so, else add \n            \n            // Get connect method\n            let url = syndicationExternalIdentityNode.nodes.find(n=>{\n              return (n.type.split(':')[0] == 'external_identity_connect_method')\n            }).data.connection;\n            \n            let reqData = {\n              type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              data: {\n                actions: [\n                  \n                  {\n                    matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                    dataForAction: {\n                      type: 'string:...',\n                      data: syndicationExternalIdentityNode.data.token\n                    }\n                  },\n                  \n                  {\n                    matchActionType: 'syndicate_shared_nodes:Qmsflkj3289j239',\n                    dataForAction: {\n                      type: 'syndicate_shared_nodes_data:Qmsdfkljwefklj223',\n                      data: writeObj, // identity_attributes_builder:Qmdsflj2301113\n                    }\n                  }\n                \n                ]\n              }\n            }\n            let response;\n            try {\n              response = await universe.webrequest.post({\n                url,\n                body: reqData,\n                json: true\n              });\n            }catch(err){\n              console.error('Failed webrequest for manage_syndication_identity_attributes_builder:', syndicationExternalIdentityNode.data.identity);\n            }\n            \n            // parse response?\n            console.log('Got response for syndicate_shared_nodes action...Success?'); \n            \n            \n          }\n          \n          \n          console.log('Syndication single complete');\n          \n          return resolve({\n            type: 'syndication_result:Qmdfkljsflskdjf',\n            data: {\n              syndicated: true\n            }\n          });\n          \n          \n          break;\n          \n          \n        \n        default:\n          console.error('Missing inputAction for capability');\n          return resolve({\n            type: 'error:Qmdsfljk',\n            data: {\n              error: true,\n              message: 'Missing inputAction for capability'\n            }\n          });\n          break;\n      }\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"
  }
}