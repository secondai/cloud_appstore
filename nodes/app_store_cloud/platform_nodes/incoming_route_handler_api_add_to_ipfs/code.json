{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "8a1aec75-e403-4e69-84ad-da2fa3652758",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      let StellarSdk = universe.require('stellar-sdk');\n      let crypto = universe.require('crypto');\n      \n      \n      console.log('--incoming_route_handler: Upload some data for a route (does NOT modify path, just handles IPFS-part)--');\n      \n      // INPUT: expressObj\n      \n      let page = {\n        type: 'ipfs_result:Qmlf3232f',\n        data: {}\n      };\n      \n      let headers = INPUT.data.req.headers;\n      let body = INPUT.data.req.body;\n      // let query = INPUT.data.req.query;\n\n      // console.log('BODY fileAsString:', body);\n      \n      \n      // Verify the person uploading \n      let sourcePublicKey = body.sourcePublicKey;\n      if(!sourcePublicKey){\n        await universe.httpResponse('send', 'Missing sourcePublicKey');\n        return resolve(true);\n      }\n      \n      // Get invite codes (root level) \n      let nodes = await universe.searchMemory({\n        filter: {\n          dataFilter: {\n            nodeId: null,\n            type: 'account_invite:Qm2934872344232324',\n            'data.sourcePublicKey': sourcePublicKey\n          },\n        }\n      });\n      if(!nodes.length){\n        console.error('unable to find sourcePublicKey:', sourcePublicKey);\n        await universe.httpResponse('send', 'Unable to find sourcePublicKey');\n        return resolve(true);\n      }\n      \n      // expecting single sourceInviteNode! \n      let sourceInviteNode = nodes[0];\n      \n      // verify incoming signature \n      let sigPair = StellarSdk.Keypair.fromPublicKey(sourcePublicKey);\n      let isValid = sigPair.verify(body.fileAsString, Buffer.from(body.sig || '','base64'));\n      \n      console.log('isValid:', isValid, body.sig);\n      \n      if(!isValid){\n        await universe.httpResponse('send', 'Not a valid signature');\n        return resolve(true);\n      }\n      \n      // signature is valid \n      \n      let ipfsFileAddResult = await universe.loadAndRunCapability('IPFS',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'file.add',\n          options: {\n            type: 'file_as_string_with_options:Qmfl2kjf23slfj',\n            data: {\n              options: {pin: true}, // INPUT.data.data.options,\n              fileValue: body.fileAsString // INPUT.data.data.fileValue\n            }\n          }\n        }\n      });\n      \n      \n      console.log('ipfsFileAddResult:', ipfsFileAddResult);\n      // await universe.updateNode(accountInviteNode);\n      \n      page.data.success = ipfsFileAddResult.data ? true:false;\n      page.data.hash = ipfsFileAddResult.data.hash;\n      \n      console.log('returning page');\n      await universe.httpResponse('send', page);\n      \n      // Update upload total \n      // - TODO: fix race condition problems \n      if(ipfsFileAddResult.data){\n        sourceInviteNode.data.uploadBytes = (sourceInviteNode.data.uploadBytes || 0) + Buffer.byteLength(body.fileAsString, 'utf8');\n        await universe.updateNode(sourceInviteNode);\n        console.log('Updated bytes');\n      }\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}