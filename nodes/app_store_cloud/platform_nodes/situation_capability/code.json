{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "note": "Capability: UserCommand",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n    \n\n      switch(inputAction){\n        case 'setup':\n          console.log('Situation Setup (default setup?)');\n          \n          return resolve({\n            type: 'boolean:...',\n            data: true\n          });\n          \n          \n        case 'compile':\n        case 'compile-all':\n          // compiles all rules, actions, matches, situations, etc. \n          console.log('Situation Compile All');\n          \n          // Fetch all rules \n          let allRules = await universe.searchMemory({\n            lean: true,\n            filter: {\n              dataFilter: {\n                nodeId: null,\n                type: {\n                  $like: 'action_rule:'\n                }\n              }\n            }\n          });\n          \n          \n          // get all Situation nodes \n          let allSituationNodes = await universe.searchMemory({\n            lean: true,\n            filter: {\n              dataFilter: {\n                nodeId: null,\n                type: {\n                  $like: 'situation_match_action:'\n                }\n              }\n            }\n          });\n          \n          for(let sitNode of allSituationNodes){\n            \n            let sitMatchNode = sitNode.nodes.find(n=>{return n.type.split(':')[0] == 'situation_match'});\n            let sitActionNode = sitNode.nodes.find(n=>{return n.type.split(':')[0] == 'situation_action'});\n            let sitActionCodeNode = sitActionNode.nodes.find(n=>{return n.type.split(':')[0] == 'code'});\n            \n            // TODO: check for missing/invalid\n            if(!sitMatchNode.data){\n              sitMatchNode.data = {}\n            }\n            if(!sitActionCodeNode.data){\n              sitActionCodeNode.data = {}\n            }\n            \n            let sitMatchBuilderNode = sitNode.nodes.find(n=>{return n.type.split(':')[0] == 'situation_match_builder'});\n            let sitActionBuilderNode = sitNode.nodes.find(n=>{return n.type.split(':')[0] == 'situation_action_builder'});\n            \n            let sitMatchBuilderNodes = sitMatchBuilderNode.nodes.sort((a,b)=>{\n              return (a.data.position - b.data.position)\n            });\n            \n            \n            \n            // re-compile Rules for Situation Builder Action \n            // - TODO: might be redundant... \n            let builderNodes = sitActionBuilderNode.nodes.sort((a,b)=>{\n              return (a.data.position - b.data.position)\n            });\n            \n            \n            // Reset rules first \n            // - removes all existing action_from_rule \n            //   - add to toRemove \n            let toRemove = [];\n            for(let actionNode of builderNodes){\n              let idx = builderNodes.indexOf(actionNode);\n              if(actionNode.type.split(':')[0] == 'action_from_rule'){\n                toRemove.push(actionNode);\n                builderNodes.splice(idx,1); // remove from array \n              }\n            }\n            \n            // remove (updateNode) \n            for(let removeNode of toRemove){\n              removeNode.active = false;\n              await universe.updateNode(removeNode);\n            }\n            \n            // reset positions \n            let toSave = [];\n            console.log('Reseting positions');\n            builderNodes = builderNodes.map((node,position)=>{\n              if(node.data.position != position){\n                node.data.position = position;\n                toSave.push(node);\n              }\n              return node;\n            });\n            for(let nodeToSave of toSave){\n              await universe.updateNode(nodeToSave);\n            }\n            \n            \n            // iterate over rules \n            for(let ruleNode of allRules){\n              console.log('rule');\n              \n              let matchNode = ruleNode.nodes.find(n=>{\n                return n.type.split(':')[0] == 'rule_match'\n              });\n              if(!matchNode){\n                console.error('Rule missing matchNode', ruleNode);\n                continue;\n              }\n              let actionNode = ruleNode.nodes.find(n=>{\n                return n.type.split(':')[0] == 'rule_action'\n              });\n              if(!actionNode){\n                console.error('Rule missing actionNode', ruleNode);\n                continue;\n              }\n              \n              // matches? \n              // - duplicates prevented from being added \n              let matches = universe.lodash.query(builderNodes, JSON.parse(matchNode.data.query));\n              console.log('Matches for ruleNode:', matches.length); //, matches);\n              if(matches.length){\n                for(let matchedBuilderActionNode of matches){\n                  // determine if already added \n                  // - TODO: this should be defined by the element itself, to allow recursion? (matching should include \"dont recurse\" condition/logic) \n                  \n                  console.log('Creating New Action From Rule', matchedBuilderActionNode);\n                  let matchedBuilderActionNodeIdx = builderNodes.indexOf(matchedBuilderActionNode);\n                  if(matchedBuilderActionNodeIdx == -1){\n                    console.error('Not a valid node');\n                    continue;\n                  }\n                  \n                  console.log('matchedBuilderActionNodeIdx:', matchedBuilderActionNodeIdx);\n                  \n                  if(!ruleNode || !ruleNode.data || !ruleNode.data.plain){\n                    console.error('Missing RuleNode data PLAIN!', ruleNode._id);\n                  }\n                  \n                  let newActionFromRuleNode = {\n                    nodeId: sitActionBuilderNode._id,\n                    type: 'action_from_rule:Qmfklj2',\n                    name: universe.uuidv4(),\n                    data: {\n                      plain: ruleNode.data.plain,\n                      code: actionNode.data.code,\n                      position: 0,\n                      matchNode: matchNode // for fun \n                    }\n                  }\n                  \n                  // create on server, get id \n                  // - TODO: better way updating everything (bulk) \n                  let savedActionFromRuleNode = await universe.newNode(newActionFromRuleNode);\n                  \n                  console.log('savedActionFromRuleNode', savedActionFromRuleNode);\n                  \n                  if(matchNode.data.location == 'before'){\n                    // push at same location \n                    builderNodes.splice(matchedBuilderActionNodeIdx, 0, savedActionFromRuleNode);\n                  } else if(matchNode.data.location == 'after') {\n                    // push after\n                    builderNodes.splice(matchedBuilderActionNodeIdx + 1, 0, savedActionFromRuleNode);\n                  }\n                  \n                }\n              }\n              \n            }\n            \n            // reset positions \n            toSave = [];\n            console.log('Reseting positions');\n            builderNodes = builderNodes.map((node,position)=>{\n              if(node.data.position != position){\n                node.data.position = position;\n                toSave.push(node);\n              }\n              return node;\n            });\n            for(let nodeToSave of toSave){\n              await universe.updateNode(nodeToSave);\n            }\n            \n            console.log('Done processing Rules');\n            \n            // re-sort after updates \n            let sitActionBuilderNodes = builderNodes.sort((a,b)=>{\n              return (a.data.position - b.data.position)\n            });\n            \n            let matchQueries = sitMatchBuilderNodes.map(builderNode=>{\n              return JSON.parse(builderNode.data.query);\n            });\n            sitMatchNode.data.query = JSON.stringify({\n              $and: matchQueries\n            })\n            \n            let codeFragments = sitActionBuilderNodes.map(builderNode=>{\n              return builderNode.data.code;\n            });\n            \n            // TODO: build a static version of this dynamic-ly built action \n            // - want to make it easy to build actions lego-like (easier for people, easier for ML) \n            \n            // INPUT is the context (search: \"nodeStateArrayForMatching\")\n            // - state of the world \n            // - pass-thru input nodes \n            // - etc. \n            \n            // Add to context request \n            // - \n            \n            // OUTPUT \n            // - \"what I'm going to do\" \n            \n            // \"continue\" Situation handling \n            // - handle new situation in Chain/Tree \n            \n            // For this Default Common First node: \n            // - add a \"processed_default_common\" flag \n            // - start another Situation, with same context nodes \n            \n            let code = `\n            (()=>{\n              return new Promise(async (resolve,reject)=>{\n                ${codeFragments.join(\"\\n\\n\")}\n              })\n            })()\n            `;\n            sitActionCodeNode.data.code = code; // .join('\\n\\n');\n            \n            // save updated!\n            await universe.updateNode(sitMatchBuilderNode);\n            await universe.updateNode(sitActionBuilderNode);\n            console.log('Updated Situation');\n            \n          }\n          \n          \n          return resolve({\n            type: 'boolean:...',\n            data: true\n          });\n          \n          \n        case 'process':\n        \n          // Incoming request to process a new Situation \n          // - evaluate/match curent state (including state of requestCache as a Node to be processed, etc.) \n          var nodeStateArrayForMatching = [\n            // memory_state\n            // request_cache \n            // pass_through_input_nodes (from the original Situation request) \n            // - contains \"situation_triggered_by\" and other nodes input from the Device (transcribed_text)\n            // - gets added to by Situations that pass-thru (add parsed_text) and similar \n          ];\n          \n          // Get state of memory \n          var allMemory = await universe.searchMemory({\n            filter: {}\n          });\n          // nodeStateArrayForMatching.push({\n          //   type: 'memory_state:Qmf3289j',\n          //   data: allMemory\n          // });\n          \n          // RequestCache (for this request)\n          let requestCache = await universe.getRequestCache();\n          // nodeStateArrayForMatching.push({\n          //   type: 'request_cache:Qmf3289j',\n          //   data: requestCache\n          // });\n          \n          // pass-through input context nodes \n          // - for data that we only want to store temporarily, over the life of the initial Situation request  \n          let passThruInputNodes = inputOpts.passThruInputNodes || [];\n          nodeStateArrayForMatching.push({\n            type: 'pass_through_input_nodes:Qmf3289j',\n            data: passThruInputNodes\n          });\n          \n          //  - match passThruInputNodes against pre-built SituationMatch objects (lodash query) \n          \n          let passThruState = passThruInputNodes.find(t=>{return t.type == 'pass_thru_internal_state:Qmtesting'})\n          if(!passThruState){\n            passThruState = {\n              type: 'pass_thru_internal_state:Qmtesting',\n              data: {}\n            };\n            passThruInputNodes.push(passThruState);\n          }\n          \n          // Find matches for a situation \n          // - create contextMatchObj to be used by all SituationMatch checks \n          //   - memoize/cache when checking, to prevent \"is state x\" checks by EVERY situation matcher node \n          \n          // TODO: reduce the possible matches by pre-reducing (dont include SituationMatch if context doest exist) \n          // - currently checking every situation every time, which is unnecessary and slow \n          var situationMatchActionNodes = await universe.searchMemory({\n            lean: true,\n            filter: {\n              dataFilter: {\n                type: {\n                  $like: 'situation_match_action:'\n                },\n                'data.enabled': true\n              }\n            }\n          });\n          \n          console.log('Possible situationMatchActionNodes:', situationMatchActionNodes.length);\n          \n          // TODO: include \"buckets\" of searching \n          // - want to exclude/eliminate as many bad matches as possible, as fast as possible \n          //   - if SituationMatches have similar requirements, group them together, and sort dependencies to test first (and eliminate wide swaths) in a performant way (what algorithm? use ML?) \n          \n          // ideally: continuous checking of the state would make this part go faster \n          \n          // iterate over SituationMatch nodes, see if matches \n          // - collect all matches, then run the code for each \n          //   - want to pass \"other matches\" into matching situation code, to make it more aware \n          \n          console.log('nodeStateArrayForMatching:', '(commented out)');\n          // console.log('nodeStateArrayForMatching:', JSON.stringify(nodeStateArrayForMatching,null,2));\n          \n          let matches = [];\n          let preResultPromises = [];\n          for(let sitMatchActionNode of situationMatchActionNodes){\n            // TODO: buid \"dynamic\" situation nodes (depending on time, other things) \n            // - should be an eval with instant return (no waiting!) \n            //   - TODO: the SituationMatch should be able to declare how often the dynamic_update needs to run \n            //     - update triggered by time, by heartbeat, Situation, etc. \n            \n            // See if match for type \n            let doesMatch;\n            \n            let sitMatchNode = sitMatchActionNode.nodes.find(n=>{return n.type.split(':')[0] == 'situation_match'});\n            if(!sitMatchNode){\n              console.error('Missing sitMatchNode:', sitMatchActionNode._id, sitMatchActionNode.data.name);\n              continue;\n            }\n            \n            let query = JSON.parse(sitMatchNode.data.query || '{}');\n            // console.log('query:', JSON.stringify(query,null,2));\n            let queryResult = universe.lodash.query(nodeStateArrayForMatching, query);\n            \n            if(queryResult.length){\n              doesMatch = true;\n            }\n            \n            if(!doesMatch){\n              // skipping\n              // console.log('skipping match (!doesMatch):', sitMatchActionNode.data.name);\n              continue;\n            }\n            \n            console.log('MATCHED sitMatchActionNode:', sitMatchActionNode.data.name);\n            matches.push(sitMatchActionNode);\n            \n            // // Run the \"pre\" for each match (deferred), saying \"hey, I'm about to activate you, can you return some info explaining what you're about to do?\" (ideally this is context-free and non-blocking) \n            // //   - that output gets compiled into an array and added to nodeStateArrayForMatching as \"resolved_pre_action_nodes\" to be used by actual actions \n            // let sitPreNode = universe.lodash.query.build(sitMatchActionNode.nodes).and({\n            //   type: {\n            //     $like: 'situation_pre_action:'\n            //   },\n            //   nodes: {\n            //     $elemMatch: {\n            //       type: {\n            //         $like: 'code:'\n            //       }\n            //     }\n            //   }\n            // }).first();\n            \n            // console.log('after sitPreNode ready');\n            \n            // if(!sitPreNode){\n            //   console.error('Missing SituationMatch pre node!', sitMatchActionNode._id);\n            // } else {\n            //   // process \"pre\" \n              \n            //   let preResult;\n            //   try {\n            //     preResult = universe.runNodeCodeInVMInMemory({\n            //       codeNode: sitPreNode.nodes.find(n=>{return n.type.split(':')[0] == 'code'}), // includes type/schemaName and data \n            //       dataNode: {},\n            //       // {\n            //       //   type: 'node_state_array_for_matching_as_cjson:Qmf3289j', // memory, context, etc. \n            //       //   data: universe.cJSON.stringify(nodeStateArrayForMatching)\n            //       // }\n            //     });\n            //   }catch(err){\n            //     console.error('FAILED code from situation_pre_action', err);\n            //     return resolve(err);\n            //   }\n              \n            //   preResultPromises.push(preResult);\n            // }\n            \n          }\n          \n          // let preResultNodes = await Promise.all(preResultPromises);\n          \n          console.log('Done running all \"matching\"');\n          // console.log('Done running all \"matching\" and \"pre\"');\n          \n          // nodeStateArrayForMatching.push({\n          //   type: 'resolved_pre_action_nodes:Qmf3298f293',\n          //   data: preResultNodes\n          // });\n          \n          // REMEMBER (note): using the \"preAction\" nodes, and actual Action code, to handle conflicts:\n          // - this is preferable to having a separate \"handle conflicts\" capability or ruleset that needs to be managed \n          // - my thinking is that it is easier to update the situation_match and situation_action \"builder\" nodes (before compile) that it is to manage a separate ruleset of handling conflicts\n          //   - not sure though, might make sense to run a Situation.handleConflicts type of capability here? \n          //     - or treat \"about to run xyz in this context\" as a Situation that can handle conflicts (starts getting a bit too recursive-y) \n          \n          // pass in the \"also running in this Situation\" nodes \n          nodeStateArrayForMatching.push({\n            type: 'running_match_action_nodes:Qmf3298f293',\n            data: matches\n          });\n          \n          // Run action nodes, collect responses \n          // - run in parallel \n          // - could potentially take awhile to respond, or could listen for further outcomes, or could start another Situation...lots of possibilities \n          \n          // TODO: actions often have a \"don't run if contextMode has \"is_test_dont_run_outcome\" \n          // - useful for training without breaking things (outcomes still found/emitted, just not processed by end-devices) \n          let actionResultPromises = [];\n          for(let actionMatch of matches){\n            \n            // actionMatch == sitMatchActionNode\n            \n            // run the SituationAction code for each (not dynamically built here, but built from parts beforehand) \n            \n            let sitActionNode = universe.lodash.query.build(actionMatch.nodes).and({\n              type: {\n                $like: 'situation_action:'\n              },\n              nodes: {\n                $elemMatch: {\n                  type: {\n                    $like: 'code:'\n                  }\n                }\n              }\n            }).first();\n            \n            if(!sitActionNode){\n              console.error('Missing SituationMatch action node!', sitMatchActionNode._id);\n            } else { \n              // process \"action\" \n              \n              let actionResult;\n              try {\n                let codeNode = sitActionNode.nodes.find(n=>{return n.type.split(':')[0] == 'code'});\n                console.log('Running compiled action for Situation:');//, codeNode.data.code);\n                actionResult = universe.runNodeCodeInVMInMemory({\n                  codeNode, // includes type/schemaName and data \n                  dataNode: {\n                    nodeStateArrayForMatching // should be a node actually, w/ a type? or an array? \n                  }\n                  // {\n                  //   type: 'node_state_array_for_matching_as_cjson:Qmf3289j', // memory, context, etc. \n                  //   data: universe.cJSON.stringify(nodeStateArrayForMatching)\n                  // }\n                });\n              }catch(err){\n                console.error('Failed situation code from runNodeCodeInVMInMemory1', err);\n                return resolve('FAILED code from situation_action', err);\n              }\n              \n              actionResultPromises.push(actionResult);\n            }\n            \n          }\n          \n          console.log('Actions to run for Situation:', actionResultPromises.length);\n          \n          let actionNodeResponses;\n          try {\n            actionNodeResponses = await Promise.all(actionResultPromises); //.map(p => p.catch(() => undefined)));\n          }catch(err){\n            console.error('actionNodeResponses error:', err);\n            actionNodeResponses = [];\n          }\n          \n          // console.log('Completed actionNodeResponses');\n          // console.log(actionNodeResponses);\n          \n          // Return the list of results for each matched/ran Situation \n          // - cjson \n          return resolve({\n            type: 'list_of_responses:...',\n            data: actionNodeResponses\n          });\n          \n        default:\n          return reject({\n            type: 'error:..',\n            data: {\n              message: 'Error in Situations (missing)'\n            }\n          });\n          \n      }\n        \n    }catch(err){\n      console.error('err2:', err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "508e6e42-51ec-44d6-aa9b-10a912da2ed8"
  }
}