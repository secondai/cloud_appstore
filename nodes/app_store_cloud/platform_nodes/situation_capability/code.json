{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "note": "Capability: UserCommand",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n    \n\n      switch(inputAction){\n        case 'setup':\n          console.log('Situation Setup (default setup?)');\n          \n          return resolve({\n            type: 'boolean:...',\n            data: true\n          });\n          \n          \n        case 'process':\n        \n          // Incoming request to process a new Situation \n          // - evaluate/match curent state (including state of requestCache as a Node to be processed, etc.) \n          var nodeStateArrayForMatching = [\n            // memory_state\n            // request_cache \n            // pass_through_input_nodes (from the original Situation request) \n            // - contains \"situation_triggered_by\" and other nodes input from the Device (transcribed_text)\n            // - gets added to by Situations that pass-thru (add parsed_text) and similar \n          ];\n          \n          // Get state of memory \n          var allMemory = await universe.searchMemory({\n            filter: {}\n          });\n          // nodeStateArrayForMatching.push({\n          //   type: 'memory_state:Qmf3289j',\n          //   data: allMemory\n          // });\n          \n          // RequestCache (for this request)\n          let requestCache = await universe.getRequestCache();\n          // nodeStateArrayForMatching.push({\n          //   type: 'request_cache:Qmf3289j',\n          //   data: requestCache\n          // });\n          \n          // pass-through input context nodes \n          // - for data that we only want to store temporarily, over the life of the initial Situation request  \n          let passthruNodes = inputOpts.passThruInputNodes || [];\n          nodeStateArrayForMatching.push({\n            type: 'pass_through_input_nodes:Qmf3289j',\n            data: passthruNodes\n          });\n          \n          //  - match against pre-built SituationMatch objects (lodash query) \n          \n          \n          // Find matches for a situation \n          // - create contextMatchObj to be used by all SituationMatch checks \n          //   - memoize/cache when checking, to prevent \"is state x\" checks by EVERY situation matcher node \n          \n          // TODO: reduce the possible matches by pre-reducing (dont include SituationMatch if context doest exist) \n          // - currently checking every situation every time, which is unnecessary and slow \n          var situationMatchActionNodes = await universe.searchMemory({\n            lean: true,\n            filter: {\n              dataFilter: {\n                type: {\n                  $like: 'situation_match_action:'\n                }\n              }\n            }\n          });\n          \n          console.log('Possible situationMatchActionNodes:', situationMatchActionNodes.length);\n          \n          // TODO: include \"buckets\" of searching \n          // - want to exclude/eliminate as many bad matches as possible, as fast as possible \n          //   - if SituationMatches have similar requirements, group them together, and sort dependencies to test first (and eliminate wide swaths) in a performant way (what algorithm? use ML?) \n          \n          // ideally: continuous checking of the state would make this part go faster \n          \n          // iterate over SituationMatch nodes, see if matches \n          // - collect all matches, then run the code for each \n          //   - want to pass \"other matches\" into matching situation code, to make it more aware \n          \n          console.log('nodeStateArrayForMatching:', JSON.stringify(nodeStateArrayForMatching,null,2));\n          \n          let matches = [];\n          let preResultPromises = [];\n          for(let sitMatchActionNode of situationMatchActionNodes){\n            // TODO: buid \"dynamic\" situation nodes (depending on time, other things) \n            // - should be an eval with instant return (no waiting!) \n            //   - TODO: the SituationMatch should be able to declare how often the dynamic_update needs to run \n            //     - update triggered by time, by heartbeat, Situation, etc. \n            \n            // See if match for type \n            let doesMatch;\n            \n            let sitMatchNode = sitMatchActionNode.nodes.find(n=>{return n.type.split(':')[0] == 'situation_match'});\n            if(!sitMatchNode){\n              console.error('Missing sitMatchNode:', sitMatchActionNode._id, sitMatchActionNode.data.name);\n              continue;\n            }\n            \n            let query = JSON.parse(sitMatchNode.data.query || '{}');\n            console.log('query:', query);\n            let queryResult = universe.lodash.query(nodeStateArrayForMatching, query);\n            \n            if(queryResult.length){\n              doesMatch = true;\n            }\n            \n            if(!doesMatch){\n              // skipping\n              // console.log('skipping match (!doesMatch):', sitMatchActionNode.data.name);\n              continue;\n            }\n            \n            console.log('MATCHED sitMatchActionNode:', sitMatchActionNode.data.name);\n            matches.push(sitMatchActionNode);\n            \n            // Run the \"pre\" for each match (deferred), saying \"hey, I'm about to activate you, can you return some info explaining what you're about to do?\" (ideally this is context-free and non-blocking) \n            //   - that output gets compiled into an array and added to nodeStateArrayForMatching as \"resolved_pre_action_nodes\" to be used by actual actions \n            let sitPreNode = universe.lodash.query.build(sitMatchActionNode.nodes).and({\n              type: {\n                $like: 'situation_pre_action:'\n              },\n              nodes: {\n                $elemMatch: {\n                  type: {\n                    $like: 'code:'\n                  }\n                }\n              }\n            }).first();\n            \n            console.log('after sitPreNode ready');\n            \n            if(!sitPreNode){\n              console.error('Missing SituationMatch pre node!', sitMatchActionNode._id);\n            } else {\n              // process \"pre\" \n              \n              let preResult;\n              try {\n                preResult = universe.runNodeCodeInVMInMemory({\n                  codeNode: sitPreNode.nodes.find(n=>{return n.type.split(':')[0] == 'code'}), // includes type/schemaName and data \n                  dataNode: {},\n                  // {\n                  //   type: 'node_state_array_for_matching_as_cjson:Qmf3289j', // memory, context, etc. \n                  //   data: universe.cJSON.stringify(nodeStateArrayForMatching)\n                  // }\n                });\n              }catch(err){\n                console.error('FAILED code from situation_pre_action', err);\n                return resolve(err);\n              }\n              \n              preResultPromises.push(preResult);\n            }\n            \n          }\n          \n          let preResultNodes = await Promise.all(preResultPromises);\n          \n          console.log('Done running all \"matching\" and \"pre\"');\n          \n          nodeStateArrayForMatching.push({\n            type: 'resolved_pre_action_nodes:Qmf3298f293',\n            data: preResultNodes\n          });\n          \n          \n          // Run action nodes, collect responses \n          // - run in parallel \n          // - could potentially take awhile to respond, or could listen for further outcomes, or could start another Situation...lots of possibilities \n          \n          // TODO: actions often have a \"don't run if contextMode has \"is_test_dont_run_outcome\" \n          // - useful for training without breaking things (outcomes still found/emitted, just not processed by end-devices) \n          let actionResultPromises = [];\n          for(let actionMatch of matches){\n            \n            // actionMatch == sitMatchActionNode\n            \n            // run the SituationAction code for each (not dynamically built here, but built from parts beforehand) \n            \n            let sitActionNode = universe.lodash.query.build(actionMatch.nodes).and({\n              type: {\n                $like: 'situation_action:'\n              },\n              nodes: {\n                $elemMatch: {\n                  type: {\n                    $like: 'code:'\n                  }\n                }\n              }\n            }).first();\n            \n            if(!sitActionNode){\n              console.error('Missing SituationMatch action node!', sitMatchActionNode._id);\n            } else { \n              // process \"action\" \n              \n              let actionResult;\n              try {\n                actionResult = universe.runNodeCodeInVMInMemory({\n                  codeNode: sitActionNode.nodes.find(n=>{return n.type.split(':')[0] == 'code'}), // includes type/schemaName and data \n                  dataNode: {}\n                  // {\n                  //   type: 'node_state_array_for_matching_as_cjson:Qmf3289j', // memory, context, etc. \n                  //   data: universe.cJSON.stringify(nodeStateArrayForMatching)\n                  // }\n                });\n              }catch(err){\n                console.error('Failed code from runNodeCodeInVMInMemory1', err);\n                return resolve('FAILED code from situation_action', err);\n              }\n              \n              actionResultPromises.push(actionResult);\n            }\n            \n          }\n          \n          let actionNodeResponses = await Promise.all(actionResultPromises);\n          \n          console.log('Completed actionNodeResponses');\n          \n          // Return the list of results for each matched/ran Situation \n          // - cjson \n          return resolve({\n            type: 'list_of_responses:...',\n            data: actionNodeResponses\n          });\n          \n        default:\n          return reject({});\n          \n      }\n        \n    }catch(err){\n      console.error('err2:', err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "508e6e42-51ec-44d6-aa9b-10a912da2ed8"
  }
}