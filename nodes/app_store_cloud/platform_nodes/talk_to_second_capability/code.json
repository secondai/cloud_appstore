{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "version": "1",
    "note": "Capability: TalkToSecond",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'talk':\n        case 'send':\n            \n            // inputOpts\n          \n          let { ExternalIdentityNode, RequestNode } = inputOpts;\n          \n          // Either http or websocket, depending on what is enabled for the ExternalIdentityNode \n          // - default to http, fallback to websocket \n          \n          // TODO: need a better way of determining which connection to use \n          \n          let httpNode = ExternalIdentityNode.nodes.find(n=>{\n            return (\n              n.type.split(':')[0] == 'external_identity_connect_method' && \n              (['http','https'].indexOf(n.data.method) > -1) &&\n              n.data.connection.indexOf('local') === -1 // NOT localhost, or .local \n            )\n          })\n          \n          let wsNode = ExternalIdentityNode.nodes.find(n=>{\n            return n.type.split(':')[0] == 'local_websocket_connection'\n          })\n          \n          let nodeResponse;\n          \n          if(httpNode){\n            \n            nodeResponse = await universe.loadAndRunCapability('Request',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'make',\n                options: {\n                  ExternalIdentityNode,\n                  RequestNode\n                }\n              }\n            });\n            \n            return resolve(nodeResponse);\n            \n          } else if(wsNode){\n            \n            // check for status == 'connected' ? \n            if(wsNode.data.status != 'connected'){\n              console.error('WebSocket not connected for Client, did NOT send TalkToSecond');\n              return reject();\n            }\n            \n            // Client or server connection? \n            // - how else to know difference? \n            const client = universe.socketioServers[wsNode.data.clientId] || universe.socketioClients[wsNode.data.clientId];\n            \n            // Send request, handle response \n            client.socket.emit('request', RequestNode, (response)=>{\n              // Response from client api (should contain \"secondResponse\" attribute! \n              console.log('Response from websocket to request:', response);\n              try {\n                let nodeResponse = response.secondResponse;\n                return resolve(nodeResponse);\n              }catch(err){\n                console.error('\"secondResponse\" not returned from websocket client when making Second api call');\n                return reject();\n              }\n            })\n            \n            return;\n            \n          }\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "e7af1532-eb2b-45f6-8673-79199855e487"
  }
}