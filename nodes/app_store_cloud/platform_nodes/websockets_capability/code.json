{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Setting up Websockets \n      // - on server/browser (depending on WINDOW availability) \n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      let doneCanWipe;\n      \n      switch(inputAction){\n        case 'setupServer':\n          // setup socketio server/manager \n          // requires http/express server on sharedServices.expressServer;\n          console.log('Setup socketio server');\n          var io = universe.require('socket.io')(universe.sharedServices.httpServer);\n          \n          // not wipe on exit \n          universe.wipeFunc = new Promise(resolve=>{\n            doneCanWipe = resolve;\n          });\n          \n          // Websockets (socketio) \n          universe.sharedServices.wsClients = {};\n          universe.sharedServices.socketioClients = {};\n          universe.sharedServices.socketIOServer = io;\n          io.on('connection', function (socket) {\n          \tconsole.log('Websocket connection');\n          \n            // Manage clients\n            let clientId = universe.uuidv4();\n            universe.sharedServices.socketioClients[clientId] = { socket };\n          \n            // notify on new connection...necessary?\n            // - should not \"await\" here, never resolves? \n          \t// app.secondAI.incomingAIRequestSocketIO({\n          \t// \ttype: 'connection',\n          \t// \tdata: null,\n          \t// \tclientId\n          \t// });\n          \n            \n            socket.on('request', async function (RequestNode, responseFunc) {\n            \t// Got a new request \n            \tconsole.log('new socketio \"request\"');\n          \n          \t\tresponseFunc = responseFunc || function(data){\n          \t\t\tconsole.log('Response (NOT sent back to requesting client, no responseFunc provided:', data);\n          \t\t}\n          \n          \t\t// app.secondAI.incomingAIRequestSocketIO({\n          \t\t// \ttype: 'request',\n          \t\t// \tdata: RequestNode,\n          \t\t// \tclientId,\n          \t\t// \tresponseFunc\n          \t\t// });\n          \t\t\n              var reqNode = {\n                type: 'incoming_web_request:0.0.1:local:29832398h4723',\n                data: {\n            \t\t\ttype: 'socketio_obj:Qmdsfkljsl29',\n            \t\t\tdata: {\n            \t\t\t\ttype: 'request', // connection, message, close  // TODO? request (response is handled by the requesting function) \n            \t\t\t\tdata: RequestNode, // the data from external \n            \t\t\t\tclientId, // for sending responses \n            \t\t\t}\n                }\n          \t\t}\n          \t\t\n          \t\tawait universe.runRequest(reqNode, true, null, null, clientId, responseFunc);\n\n          \n            });\n          \n            socket.on('message', function (RequestNode, responseFunc) {\n            \tconsole.log('Got MESSAGE via socketio, expecting \"request\" key');\n            \tif(responseFunc){\n            \t\tresponseFunc('Invalid key \"message\" should be \"request\"');\n            \t} else {\n            \t\tconsole.log('callback/response function not provided with request')\n            \t}\n            });\n          \n            socket.on('close', ()=>{\n            \tconsole.log('Socketio CLOSED');\n            })\n          \n          });\n          \n          console.log('SocketIO server setup');\n          \n          return resolve({\n            type:'boolean:...',\n            data: true\n          })\n          \n          \n          \n        case 'setupClient':\n          console.log('setup socketio client on sharedServices');\n          universe.sharedServices.socketioClient = universe.require('socket.io-client')\n          \n          return resolve({\n            type:'boolean:...',\n            data: true\n          })\n          \n          \n          \n        case 'setupAllExistingTunnels':\n          // Loads all ExternalIdentity nodes and creates a link to each \n          // - must be existing (doesnt add new ones on startup) \n          \n          console.log('Setup websocket links/tunnels for all ExternalIdentityNodes');\n          \n          // have ExternalIdentity.nodes.local_websocket_connection \n          \n          //connecting this Second (client) with the remote Second (server) \n          // - local_websocket_connection for both, but either isClient or isServer \n          \n          let ExternalIdentities = await universe.searchMemory({\n            filter: {\n              dataFilter: {\n                nodeId: null,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                // nodes: \n              },\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    return tmpNode.nodes.find(n=>{\n                      return (n.type.split(':')[0] == 'local_websocket_connection') && (n.data.isServer === true)\n                    })\n                  })\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          for(let ExternalIdentityNode of ExternalIdentities){\n            // run in parallel\n            universe.loadAndRunCapability('Websockets',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'initLink',\n                options: {\n                  ExternalIdentityNode\n                }\n              }\n            });\n          }\n          \n          \n          return resolve({\n            type:'boolean:...',\n            data: true\n          })\n          \n          break;\n        \n        \n        case 'initLink':\n          // Initiate active link with passed-in ExternalIdentity \n          \n          // - acts as the client (slave) in websocket connection \n          //   - creates connection to remote \n          //   - upgrades connection using token (already should have authenticated!) \n          //   - socketio is already loaded (available as universe.sharedServices.socketClient); \n          console.log('Websockets initLink capability');\n          \n          // INPUT: external identity node, to be updated with clientId of WINDOW.sockets \n          \n          // TODO: see if we have an existing connection for the ExternalIdentityNode? \n          \n          // Manage clients\n          var clientId = universe.uuidv4();\n        \n          let ExternalIdentityNode = inputOpts.ExternalIdentityNode;\n          console.log('ExternalIdentityNode:', ExternalIdentityNode); // should be http or https (match current location, default https) \n          \n          let serverNode = ExternalIdentityNode.nodes.find(n=>{\n            return n.type.split(':')[0] == \"external_identity_connect_method\" && (['http','https'].indexOf(n.data.method) > -1)\n          })\n          \n          if(!serverNode){\n            console.error('Missing external_identity_connect_method for remote Second for websockets');\n            return false;\n          }\n          \n          let parser;\n          let connection;\n          \n          if(typeof WINDOW != 'undefined'){\n            parser = WINDOW.document.createElement('a');\n            parser.href = serverNode.data.connection;\n            connection = '//' + parser.host; // includes hostname:port. expecting same protocol as current host (http/https) \n          } else {\n            const { URL } = universe.require('url');\n            parser = new URL(serverNode.data.connection);\n            connection = '//' + parser.host; // includes hostname:port\n          }\n          \n          console.log('Setting up websocketClient (as slave):', connection);\n          \n          var io = universe.sharedServices.socketioClient;\n          if(!universe.sharedServices.socketioServers){\n            universe.sharedServices.socketioServers = {};\n          }\n          \n          // console.log('IO:', io);\n          // console.log('socketioServers', universe.sharedServices.socketioServers);\n          // console.log('connection', connection);\n          \n          // console.log('IO:', io);\n          console.log('Getting socket', io ? true:false)\n          let socket = io('ws:' + connection); \n          \n          console.log('Got socket')\n          // universe.socketioServers = universe.socketioServers || {};\n          universe.sharedServices.socketioServers[clientId] = { ExternalIdentityNode, socket };\n          \n          console.log('socketioServers set:', clientId);\n          \n          // Update local ExternalIdentityNode with clientId for websocket \n          // - create/update local node \n          let wsNode = ExternalIdentityNode.nodes.find(n=>{\n            return n.type.split(':')[0] == 'local_websocket_connection'\n          });\n          if(!wsNode){\n            // create \n            console.log('Creating wsNode');\n            wsNode = await universe.newNode({\n              nodeId: ExternalIdentityNode._id,\n              name: universe.uuidv4(),\n              type: 'local_websocket_connection:Qmf3289',\n              data: {\n                isServer: true,\n                clientId,\n                status: null\n              }\n            });\n          } else {\n            // update \n            console.log('Updating wsNode');\n            wsNode.data.isServer = true;\n            wsNode.data.clientId = clientId;\n            wsNode.data.status = null;\n            wsNode = await universe.updateNode(wsNode);\n          }\n          \n          console.log('wsNode after create/update:', wsNode);\n          \n          socket.on('connect', async ()=>{\n            console.log('Connected websocket (listening)!');\n            \n            // Update status \n            wsNode.data.status = 'connected';\n            await universe.updateNode(wsNode);\n            \n            console.info('wsNode updated, now waiting for requests');\n            \n            // Handle incoming socket requests \n            // - runRequest \n              \n            socket.on('request', async (RequestNode, responseFunc)=>{\n            \t// let requestId = uuidv4();\n             //  console.log('RequestNode:', RequestNode);\n            \n              let responseNode;\n              \n             console.log('Got websocket request form server, processing', RequestNode); \n          \n          \t\tresponseFunc = responseFunc || function(data){\n          \t\t\tconsole.log('Response (NOT sent back to requesting client, no responseFunc provided:', data);\n          \t\t}\n          \t\t\n              try {\n                // Handle request using normal flow (creates new Request w/ requestId, new cache, etc) \n                // InputNode, skipWrappingInputNode, reqObj, resObj, wsClientId, socketioResponseFunc\n                var reqNode = {\n                  type: 'incoming_web_request:0.0.1:local:29832398h4723',\n                  data: {\n              \t\t\ttype: 'socketio_obj:Qmdsfkljsl29',\n              \t\t\tdata: {\n              \t\t\t\ttype: 'request', // connection, message, close  // TODO? request (response is handled by the requesting function) \n              \t\t\t\tdata: RequestNode, // the data from external \n              \t\t\t\tclientId, // for sending responses \n              \t\t\t}\n                  }\n            \t\t}\n            \t\t\n            \t\t// response is handled by httpResponse \n                await universe.runRequest(reqNode, true, null, null, clientId, responseFunc);\n                \n              }catch(err){\n                console.error('Failed websocket request/response (runRequest failed):', err);\n                responseNode = {\n                  type: 'error:Qmslfj',\n                  data: {\n                    msg: 'Failed websocket request/response (runRequest failed)',\n                    err\n                  }\n                }\n                responseFunc(responseNode);\n              }\n              \n              // responseFunc(responseNode);\n              \n            });\n            \n            \n            // Run capability for websocket authentication \n            // - so that the remote (master) websocket server can know which external_identity the websocket is for \n            // - also linking local OwnerSecondExternalIdentityNode to socket, for TalkToSecond \n            \n            let linkRequestNode = {\n              type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              data: {\n                actions: [\n                  {\n                    matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                    dataForAction: {\n                      type: 'string:...',\n                      data: ExternalIdentityNode.data.token\n                    }\n                  },\n                  {\n                    matchActionType: 'link_websocket_to_identity:Qmf2398sdoihf',\n                    dataForAction: {\n                      type: 'options_object:...',\n                      data: {}\n                    }\n                  },\n                ]\n                \n              }\n            }\n            console.log('Emitting linkRequestNode for websocket clientId upgrade', JSON.stringify(linkRequestNode,null,2));\n            socket.emit('request', linkRequestNode, async (ResponseNode)=>{\n              // console.log('Response from server for linkRequestNode (via websocket)', JSON.stringify(ResponseNode,null,2));\n              try {\n                let successResponse = ResponseNode.secondResponse.data.actionResponses[1].data;\n                if(successResponse === true){\n                  console.log('linkRequestNode Success, websocket connection setup');\n                } else {\n                  console.error('linkRequestNode Failed, websocket connection NOT setup (no exception, err:)', ResponseNode);\n                }\n              }catch(err){\n                console.error('linkRequestNode Failed, websocket connection NOT setup', err);\n              }\n              \n            });\n            \n            \n            \n          });\n          // socket.on('event', function(data){});\n          socket.on('disconnect', async ()=>{\n            console.log('disconnected websocket');\n            \n            wsNode.data.status = 'disconnected';\n            await universe.updateNode(wsNode);\n            \n          });\n          \n          socket.on('error', async (err)=>{\n            console.error('Websocket Error:', err);\n          });\n          \n          // WINDOW.SOCKET = socket;\n          \n        \n          return resolve({\n            type:'boolean:...',\n            data: true\n          })\n          \n        \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "cae006a6-7c84-4de4-b87b-5ef7c675440a"
  }
}