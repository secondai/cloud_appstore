{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "caa31b79-0ffc-417a-b7cc-9ed5d61332a6",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // ONLY FOR: generic_cloud_second \n      \n      console.log('--Incoming request to app_base incoming_from_uni--');\n      // handles an incoming Node from the Universe \n      // - handles the majority of request types:\n      //   - web request \n      //   - internal heartbeat \n      //   - internal \"wakeup\" \n      \n      // This accepts a Node that defines the type of data it is, and how we should start handling the request \n      // - the \"if I know nothing, learn things\" command is in here as well \n      \n      // console.log('INPUT:', JSON.stringify(INPUT,null,2));\n      \n      \n      switch(INPUT.type){\n          \n        case 'incoming_first:0.1.1:local:78882h37':\n          \n          console.log('INCOMING FIRST11!!');\n          \n          // INPUT is an ExternalIdentityNode\n          // return resolve({\n          //   learning: true,\n          //   INPUT\n          // });\n          \n          // Determine if environment if browser, cloud, app\n          // - determine if we ask for what to download? \n          \n          // This is called only once, after \"learnBasics\" populated default Nodes \n          // - basic capabilities are included/available  \n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'createLocal',\n              options: {}\n            }\n          });\n          \n          console.log('newIdentityNode', JSON.stringify(newIdentityNode,null,2));\n          \n          \n          // STOPPING HERE! \n          // - not \"learning\" anything from remote, just using whatever is currently available (JSON-start)\n          \n          console.log('Created Identity on _first, Second all ready!');\n          \n          // Register Identity on remote \n          let registeredExternal = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'registerOnChain',\n              options: {\n                words: universe.env.STARTUP_REACHABLE_WORDS,\n                publicKey: newIdentityNode.data.public,\n                connection: newIdentityNode.nodes[0].data.connection\n              }\n            }\n          });\n          \n          \n          return resolve({\n            type: 'something2...',\n            data: {\n              createdIdentity: true,\n              registeredExternal\n              // WORDS: universe.env.STARTUP_REACHABLE_WORDS,\n              // publicKey: newIdentityNode.data.public,\n              // connection: newIdentityNode.nodes[0].data.connection\n            }\n          });\n          \n          \n          \n          \n          // // Find remote Second \n          // // - hash of keywords -> wallet address -> encrypted via last keyword? \n          // // - want a publicKey and a URL returned \n          // //   - a whole IdentityNode should be returned? \n          // // - return: \n          // //   - external_identity:0.0.1:local:8982f982j92\n          // //   - external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          // let remoteValue;\n          // try {\n          //   remoteValue = 'test test'; //WINDOW.prompt('Remote Second','test test');\n          // }catch(err){\n          //   console.error('Not in Tab');\n          //   remoteValue = 'test test';\n          // }\n          \n          // // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // // - uses a constant value (token) from the remote Second! \n          // let addressNode = await universe.loadAndRunCapability('Identity',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'getAddressForWords',\n          //     options: {\n          //       words: remoteValue\n          //     }\n          //   }\n          // });\n          \n          // let address = addressNode.data;\n          \n          // // fetch that wallet address, get the first transaction \n          // // - first transaction contains IPFS link \n          // // - IPFS contains Nodes (without _ids!) \n          // let ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          // // console.log('Got ExternalIdentityNode',ExternalIdentityNode);\n          \n          // // return resolve({\n          // //   ExternalIdentityNode,\n          // //   error: true,\n          // //   remoteValue,\n          // //   address\n          // // })\n          \n          // // return resolve({\n          // //   aboutToIdentity: true\n          // // });\n          \n          // // Authenticate with External Second \n          // // - make authenticated requests to a Second (necessary for Learning?) \n          // //   - should have ALL requests authenticated \n          // // universe.setupExternalSecond();\n          // let authExternalIdentityNode = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'start',\n          //     options: {\n          //       externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n          //       authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e'\n          //     }\n          //   }\n          // });\n          \n          // console.log('FINISHED INITIATE!', authExternalIdentityNode);\n          \n          // // console.log('ExternalIdentityNode', JSON.stringify(ExternalIdentityNode,null,2));\n          \n          // // Connect to passed-in data (ExternalIdentityNode) \n          // // - run a search_internal_datasource action sequence to acquire the code to run \n          // // - run the code on local Second  \n          // let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'send',\n          //     options: {\n          //       ExternalIdentityNode,\n          //       RequestNode: {\n          //         type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n          //         data: {\n          //           actions: [\n                            \n          //             {\n          //               matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n          //               dataForAction: {\n          //                 type: 'string:...',\n          //                 data: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" token is here! pre-downloaded!\n          //               }\n          //             },\n                      \n          //             {\n          //               matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n          //               dataForAction: {\n          //                 type: 'standard_query_request:0.0.1:local:65723f2khfds',\n          //                 data: {\n          //                   matchFunctionNode: {\n          //                     // query here!\n          //                     // action_pointer:0.0.1:local:238972ncr\n          //                     type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n          //                     data: {\n          //                       code: `(()=>{\n          //                         // Action \n          //                         // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                  \n          //                         let inputNode = INPUT.data.inputNode;\n                                  \n          //                         if(inputNode.type != 'learning_pointer:0.0.1:local:3289h3238h92'){\n          //                           return null;\n          //                         }\n                                  \n          //                         if(inputNode.data.learn != 'generic_cloud_second'){\n          //                           return null;\n          //                         }\n                                  \n          //                         if(inputNode.nodeId){\n          //                           // should be root-level!\n          //                           return null;\n          //                         }\n                                  \n          //                         // strip childnodes\n          //                         // delete inputNode.nodes; \n          //                         // delete inputNode.parent;\n          //                         delete inputNode.data;\n          \n          //                         return inputNode;\n                                  \n          //                       })()`\n          //                     }\n          //                   },\n          //                   // expected/allowed schemas for return \n          //                   // outputSchemas: [\n          //                   //   'query_result:0.0.1:local:32490usfj23o23f',\n          //                   //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n          //                   // ]\n          //                 }\n          //               }\n          //             }\n          //           ]\n                    \n          //         }\n          //       }\n          //     }\n          //   }\n          // });\n          \n          // // console.log('Got Response from TalkToSecond3'); //, JSON.stringify(response,null,2));\n          \n          // // Response should include code! \n          // let codeResultNode = universe.lodash.find(response.data.actionResponses[1].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n          \n          \n          // console.log('Got Code to Run for generic_cloud_second');\n          \n          // // return resolve({\n          // //   runningRemoteCode: true,\n          // //   codeResultNode_type: codeResultNode.type\n          // // });\n          \n          // // Run code in local VM \n          // // - INPUT.data is ExternalIdentityNode \n          // // - clears local memory, gets remote app, KEEPS local identity! \n          // let localResult = await universe.runNodeCodeInVM({\n          //   codeNode: codeResultNode,\n          //   dataNode: INPUT.data\n          // });\n          \n          // return resolve({\n          //   externalResponse: true,\n          //   response,\n          //   codeResultNode,\n          //   localResult\n          // })\n          \n          \n        case 'incoming_startup:Qmf3289h9293fhsb':\n          // Startup/Wakeup \n          // - handles loading capabilities that will be used later \n          //   - loads all Capabilities (require things in?), adds them to GlobalCache \n          //   - on subsequent requests, universe.capabilities() should work. \n          \n          console.log('Incoming Startup/Wakeup');\n          \n          // Start Scheduler \n          await universe.loadAndRunCapability('Scheduler',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'start',\n              options: {}\n            }\n          });\n          \n          return resolve({\n            type: 'boolean:...',\n            data: true\n          });\n          \n          \n          \n          break;\n          \n        case 'incoming_heartbeat:0.0.1:local:23849u492348c7n9':\n          // Heartbeat (ever 1 second or so is expected) \n          break;\n          \n        case 'incoming_web_request:0.0.1:local:29832398h4723':\n          // request via HTTP post method (expressjs server expected) \n          // - headers and body are included\n          //   - body is JSON (expected to be!) \n          \n          // console.log('incoming_web_request!!');\n          // return resolve({\n          //   ok: true\n          // });\n              \n          // if(INPUT.type == 'run_action:0.0.1:local:2398y294c23'){\n            // this is the main/expected input\n            \n            // // Get current app_base for this CodeNode \n            // let appBaseNode = await universe.appBaseOf(SELF._id);\n  \n            // try {\n            //   console.log('SEARCH1');\n            //   console.log(SELF._id);\n            //   console.log(SELF.parent._id);\n            //   console.log(SELF.parent.parent._id);\n            //   console.log('SEARCH2');\n            // }catch(err){\n            // }\n            \n            // expecting a full express.req object in INPUT \n            // - headers, paths, body, etc. \n            \n            let expressNode = INPUT.data; // INPUT.data.type == 'express_obj:Qmdsfkljsl'\n            \n            \n            let headers = expressNode.data.req.headers;\n            let body = expressNode.data.req.body;\n            \n            \n            console.log('Path:', expressNode.data.req.path);\n            // console.log('BODY:', JSON.stringify(body,null,2));\n            // console.log('ExpressNode:', universe.cJSON.stringify(expressNode,null,2));\n            \n            \n            // Load routes, controllers for each (TODO) \n            // - MVC-like for web requests, expecting most non-node requests to be authentication one-offs \n            \n            \n            // cache the action code \n            let cacheAppId = universe.getParentRoot(SELF)._id;\n            let cache = ['incoming_web_request_route_nodes', cacheAppId].join('|');\n            \n            // app root-level (old: global-root) \n            let routeNodes = await universe.searchMemory({\n              cache,\n              filter: {\n                sqlFilter: {\n                  // nodeId: null // OLD: root-level\n                  type: 'incoming_route_handler:Qmsdfkj329j3'\n                },\n                // function for returning data from the Node, after filtering a bit \n                // - includes both the Node, and Nodes with nodeId (pointers) \n                filterNodes: tmpNodes=>{\n                  // this runs isolated, outside of the above context? (not sure..think it is same context though [using INPUT.data.type in search]) \n                  return new Promise((resolve, reject)=>{\n                    tmpNodes = tmpNodes.filter(tmpNode=>{\n                      // see if has a ChildNode matching a type \n                      \n                      if(!universe.sameAppPlatform(SELF, tmpNode)){\n                        // console.log('FOUND IT UNDER SAME APP!!!!!', tmpNode._id);\n                        return false;\n                      }\n                      \n                      return true;\n                      \n                    });\n                    resolve(tmpNodes);\n                  });\n                },\n              }\n            });\n            \n            console.log('Sort routes');\n            \n            // prevent \"/ai\" from being pushed to the bottom! \n            // - mucking with /ai will cause some serious problems! \n            \n            let routes = routeNodes.sort((a,b)=>{\n              try {\n                  // multiple /ai's?\n                if(a.data.ai && !b.data.ai){\n                  return -1;\n                }\n                if(b.data.ai && !a.data.ai){\n                  return 1;\n                }\n                return (a.data.priority > b.data.priority) ? 1:-1; // lower priority => checked first!\n              }catch(err){\n                console.error('err sorting routes:', err);\n                return 0;\n              }\n            }).map(routeNode=>{\n              // get codeNode to run \n              let routeTxtMatches = routeNode.data.routes || []; // multiple allowed \n              \n              let routeCodeNodeToRun = universe.lodash.find(routeNode.nodes,{type:'code:0.0.1:local:32498h32f2'});\n              \n              return [routeTxtMatches, routeCodeNodeToRun];\n            });\n            \n            console.log('Checking routes', routes.length);\n            \n            // // print out routes to check (order\n            // for(let route1 of routes){\n            //   console.log('ROUTECheck1:',JSON.stringify(route1[0]));\n            // }\n            \n            let routed = false;\n            for(let route of routes){\n              if(routed){continue}\n              for(let tmpMatchRoute of route[0]){\n                if(routed){continue}\n                let tmpRoute = new universe.RouteParser(tmpMatchRoute);\n                let match = tmpRoute.match(expressNode.data.req.path)\n                if(match){\n                  routed = true;\n                  \n                  console.log('MATCH ROUTE:', match ? true:false, tmpMatchRoute, match);\n                  \n                  // update expressNode with params\n                  expressNode.data.params = match;\n                  \n                  // run in vm, and pass in the inputSchema Node! \n                  // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n                  let routeResult;\n                  try {\n                    console.log('Getting routeResult');\n                    routeResult = await universe.runNodeCodeInVM({\n                      codeNode: route[1], // includes type/schemaName and data \n                      dataNode: expressNode, // passes express obj, with req, res \n                      timeout: 15 * 1000\n                    });\n                  }catch(err){\n                    return resolve('FAILED code from incoming_web_request, trying to run route');\n                  }\n                  \n                  console.log('executed route, expecting to have already responded using expressNode.data.res.send()');\n                  return resolve({\n                    type: 'executed_route:Qmmf3290jhgj',\n                    data: true\n                  });\n                  \n                }\n              }\n            }\n            \n            if(!routed){\n              console.log('No Matches');\n              await universe.httpResponse('send','404 - Missing Page');\n              return resolve({\n                type: 'missing_route:Qm404sfhsf',\n                data: false\n              });\n            }\n            \n          break;\n          \n        case 'incoming_web_request_blob:0.0.1:local:293h98h92f3':\n          // todo: handle incoming Blob data \n          break;\n          \n        case 'incoming_web_request_websocket:0.0.1:local:293h98h92f3':\n          // todo: handle incoming websocket request \n          // - could also be on browser? \n          break;\n          \n        case 'incoming_browser_request:0.0.1:local:829329329f832':\n          // incoming request (if in a browser) \n          break;\n          \n          \n        default:\n          return resolve({\n            type: 'err:..',\n            data: {\n              msg: 'Missing valid input type',\n              INPUT\n            }\n          });\n      }\n\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}