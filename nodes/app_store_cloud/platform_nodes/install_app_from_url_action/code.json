{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "63c8bfa5-289b-4d8b-b8f5-6e8908fd1ac2",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n            \n      let __parsedFiles = {};\n      function jsonParse(key, contents){\n        if(__parsedFiles[key]){\n          return __parsedFiles[key]\n        }\n      \n        __parsedFiles[key] = JSON.parse(contents);\n        return __parsedFiles[key];\n      \n      }\n\n      // overwrite an internal appId app_base from github repo \n      // - if multiple fail? \n      // - completely overwrites \n       \n      // INPUT: {\n      //   type: 'update_app_base_data:Qmdsfkjsl..',\n      //   data: {\n      //     appId: what to overwrite\n      //   }\n      // }\n    \n      // let tmpNodeData = {\n      //   //nodeId:  // root level? TODO: find put in correct folder? \n      //   name: universe.uuidv4(),\n      //   type: \"tmp_shared_node:Qmsdfkj\",\n      //   data: {\n      //   }\n      // }\n      // let savedTmpNode = await universe.newNode(tmpNodeData);\n      \n      // savedTmpNode = await universe.updateNode(savedTmpNode);\n      \n      \n      // Find local app_base for incoming app_id \n      \n      // handleUpdate\n      \n      console.log('INPUT for install_app_from_url_action:', INPUT);\n  \n\n      let url = INPUT.data.url; \n  \n  \t  console.log('zip URL:', url);\n  \n  \t  universe.webrequest({\n  \t    url,\n  \t    encoding: null\n  \t  })\n  \t  // .then(response=>{\n  \t  //   // return response.arrayBuffer();\n  \t  //   console.log('Got .zip response', response.length);\n  \t  //   return response;\n  \t  // })\n  \t  .then(universe.JSZip.loadAsync)\n  \t  .then(async (zip)=>{\n  \t    console.log('loaded zip data!'); //, zip);\n  \n  \t    // ZIP is valid! \n  \t    let files = zip.files;\n  \n  \t    function readFilePath(p){\n  \t      return new Promise(async (resolve,reject)=>{\n  \t        console.log('path:', p);\n  \t        let r = await files[p].async('text')\n  \t        resolve(r);\n  \t      });\n  \t    }\n  \n  \t    // load all the files \n  \t    let allFiles = {};\n  \t    for(let filepath of Object.keys(files)){\n  \t      let file = files[filepath];\n  \t      if(file.dir){\n  \n  \t      } else {\n  \t        // console.log('filepath:', filepath);\n  \t        let contents = await readFilePath(filepath);\n  \t        // console.log('contents:', contents);\n  \t        let normalizedPath = filepath.split('/').splice(1).join('/');\n  \t        allFiles[normalizedPath] = contents;\n  \t      }\n  \t    }\n  \n  \n        function addChildren(path){\n          return new Promise(async (resolve,reject)=>{\n          \n            let nodes = [];\n            try {\n                \n              for(let filepath of Object.keys(allFiles)){\n                let contents = allFiles[filepath];\n                if(filepath.indexOf(path) !== 0){\n                  // console.log('NOT NODE:', filepath);\n                  continue;\n                }\n                let pathDepth = path.split('/').length;\n                let filepathDepth = filepath.split('/').length;\n                if(pathDepth == filepathDepth){\n                  // xyz.json at correct depth\n                  \n                  let parsed = jsonParse(filepath, contents);\n                  // if(parsed.nodeId == id){\n                    // console.log('Matches ID:', parsed.nodeId, id);\n                    let children = await addChildren(filepath.slice(0, filepath.length - 5) + '/'); // remove '.json'\n                    parsed.nodes = children;\n                    nodes.push(parsed);\n                  // } else {\n                  //   // console.log('No Kids:', id, parsed.nodeId);\n                  // }\n                }\n  \n  \n              }\n            }catch(err){\n              console.error(err);\n            }\n  \n            resolve(nodes);\n            \n          });\n        }\n  \n  \t    // re-organize child nodes \n  \t    ZipNodes = await addChildren('nodes/'); // start at root, adds children recursively \n  \n  \t    let secondJson = JSON.parse(allFiles['second.json']);\n  \t    // let basicKey = secondJson.name; \n  \n        // Expecting 1 root_level app_base from ZipNodes\n        let firstAppBaseNode = ZipNodes[0]; \n        if(firstAppBaseNode.data.appId != INPUT.data.appId){\n          return resolve({\n            type: 'error:Qmdsflj',\n            data: {\n              error: true,\n              message: 'unable to find app_base as first root node from zip nodes'\n            }\n          });\n        }\n        \n  \t    console.log('Resolved all!', ZipNodes.length);\n  \t    \n  \t    let appId = firstAppBaseNode.data.appId;\n  \t    \n  \t    // Determine if already-existing app \n  \t    \n        let localAppBases = await universe.searchMemory({\n          filter: {\n            filterNodes: tmpNodes=>{ \n              return new Promise((resolve, reject)=>{\n                tmpNodes = tmpNodes.filter(tmpNode=>{\n                  if(tmpNode.nodeId){\n                    return false;\n                  }\n                  if(tmpNode.type.split(':')[0] != 'app_base'){\n                    return false;\n                  }\n                  if(tmpNode.data.appId != appId){\n                    return false;\n                  }\n                  return true;\n                });\n                resolve(tmpNodes);\n              });\n            },\n          }\n        });\n        console.log('localAppBaseslength:', localAppBases.length);\n        \n        if(localAppBases && localAppBases.length){\n          let localAppBase = localAppBases[0];\n          if((localAppBase.data.appId == firstAppBaseNode.data.appId) || \n            (localAppBase.name == firstAppBaseNode.name)){\n            // name or appId conflict (cannot have two of the same app?) \n            console.error('Conflict with existing name or appId of app_base');\n            return resolve({\n              type: 'error:Qmdsflsj',\n              data: {\n                error: true,\n                message: 'Conflict with existing name or appId of app_base'\n              }\n            });\n          }\n        }\n\n  \t    \n  \t    // Insert all new ZipNodes \n        const saveChildNodes = (nodeId, childNodes) => {\n          return new Promise(async (resolve, reject)=>{\n            \n            for(let tmpNode of childNodes){\n              let newChildNode = {\n                name: tmpNode.name,\n                nodeId,\n                type: tmpNode.type,\n                data: tmpNode.data,\n              }\n              \n  \t\t\t\t\t\tlet savedChildNode = await universe.newNode(newChildNode, true, true);\n  \n              if(tmpNode.nodes && tmpNode.nodes.length){\n  \n                await saveChildNodes(savedChildNode._id, tmpNode.nodes);\n  \n              }\n            }\n            resolve();\n          });\n        }\n        \n        console.log('firstAppBaseNode:', firstAppBaseNode);\n        \n        // should check for a name mismatch!\n        delete firstAppBaseNode._id; // starting anew internally \n        firstAppBaseNode.name = firstAppBaseNode.name + '_' + Date.now();\n        let newAppBaseNode = await universe.newNode(firstAppBaseNode, true, true);\n        await saveChildNodes(newAppBaseNode._id, firstAppBaseNode.nodes);\n  \t    \n  \t    // rebuild memory after bulk inserts\n  \t    await universe.rebuildMemory();\n  \t    \n  \t    console.log('Complete, installed app_base on Second from zip url');\n  \t    \n  \t    return resolve({\n  \t      type: 'boolean:Qmsdflj',\n  \t      data: true\n  \t    \t// nodes: ZipNodes,\n  \t    \t// config: secondJson\n  \t    });\n  \n  \t });\n      \n      \n    }catch(err){\n      console.error('FAILED install_app_from_url_action',err);\n      \n      return resolve({\n        // savedNode\n        type: 'error:..',\n        data: {\n          msg: 'Failed update_app_base_action',\n          INPUT,\n          error: true,\n          err: err\n        }\n      });\n      // resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"
  }
}