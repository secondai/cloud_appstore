{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "90bd3427-5301-415d-ac12-c3f9a3c530d0",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'make':\n        \n          console.log('Make Request inputOpts', inputOpts);\n          \n          // Make a request to an external Second \n          // inputOpts: {\n          //   ExternalIdentityNode, // must include connect_method\n          //   RequestNode: InitiateIdentifyNode\n          // }\n          \n          // let ExternalRequestNode = inputOpts.ExternalIdentityNode;\n          \n          \n          let httpNode = ExternalIdentityNode.nodes.find(n=>{\n            return (\n              n.type.split(':')[0] == 'external_identity_connect_method' && \n              (['http','https'].indexOf(n.data.method) > -1) &&\n              n.data.connection.indexOf('local') === -1 // NOT localhost, or .local \n            )\n          })\n          \n          let wsNode = ExternalIdentityNode.nodes.find(n=>{\n            return n.type.split(':')[0] == 'local_websocket_connection'\n          })\n          \n          let nodeResponse;\n          let response;\n          \n          if(httpNode){\n          \n            response = await universe.directToSecond({\n              url: httpNode.data.connection,\n              RequestNode: inputOpts.RequestNode,\n              // method: 'post',\n              // url: connectNode.data.connection, // expecting URL at first! \n              // body: ExternalRequestNode.data.RequestNode,\n              // json: true\n            })\n            return resolve(response.secondResponse);\n            \n          } else if(wsNode){\n            \n            // check for status == 'connected' ? \n            if(wsNode.data.status != 'connected'){\n              console.error('WebSocket not connected for TalkToSecond, did NOT send request');\n              return reject();\n            }\n            \n            // Client or server connection? \n            // - how else to know difference? \n            const client = universe.sharedServices.socketioServers[wsNode.data.clientId] || universe.sharedServices.socketioClients[wsNode.data.clientId];\n            \n            // Send request, handle response \n            client.socket.emit('request', RequestNode, (response)=>{\n              // Response from client api (should contain \"secondResponse\" attribute! \n              console.log('Response from websocket to request:', response);\n              try {\n                let nodeResponse = response.secondResponse;\n                return resolve(nodeResponse);\n              }catch(err){\n                console.error('\"secondResponse\" not returned from websocket client when making Second api call');\n                return reject();\n              }\n            })\n            \n            return;\n            \n          } else {\n            console.log('Unable to make Request! missing httpNode or wsNode');\n            return reject({\n              type: 'error:Qmdsfk',\n              data: 'Unable to make Request! missing httpNode or wsNode'\n            });\n          }\n\n          // // ExternalIdentityNode needs to have a NodeChild w/ a connect_method \n          // let connectNode = universe.lodash.find(inputOpts.ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n          // if(!connectNode){\n          //   console.error('Missing ConnectNode!');\n          //   return reject({\n          //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          //     data: {\n          //       str: 'Missing existing ExternalIdentity connect_method child!'\n          //     }\n          //   })\n          // }\n\n          // console.log('Making external request');\n\n          // // Requesting via HTTP or Websocket? \n          // // - websocket simulates a request/response \n          // let response;\n          // switch(connectNode.data.type){\n          //   case 'http':\n          //   case 'https':\n                  \n          //     // make web request\n          //     // - just passing through, assume any Auth is already included \n          //     response = await universe.directToSecond({\n          //       url: connectNode.data.connection,\n          //       RequestNode: inputOpts.RequestNode,\n          //       // method: 'post',\n          //       // url: connectNode.data.connection, // expecting URL at first! \n          //       // body: ExternalRequestNode.data.RequestNode,\n          //       // json: true\n          //     })\n          //     break;\n              \n          //   case 'ws':\n          //   case 'wss':\n          //     // Does NOT use directToSecondViaWebsocket\n              \n          //     // // check for status == 'connected' ? \n          //     // if(wsNode.data.status != 'connected'){\n          //     //   console.error('WebSocket not connected for Client, did NOT send TalkToSecond');\n          //     //   return reject();\n          //     // }\n              \n          //     // // Client or server connection? \n          //     // // - how else to know difference? \n          //     // const client = universe.sharedServices.socketioServers[wsNode.data.clientId] || universe.sharedServices.socketioClients[wsNode.data.clientId];\n              \n          //     // // Send request, handle response \n          //     // client.socket.emit('request', RequestNode, (response)=>{\n          //     //   // Response from client api (should contain \"secondResponse\" attribute! \n          //     //   console.log('Response from websocket to request:', response);\n          //     //   try {\n          //     //     let nodeResponse = response.secondResponse;\n          //     //     return resolve(nodeResponse);\n          //     //   }catch(err){\n          //     //     console.error('\"secondResponse\" not returned from websocket client when making Second api call');\n          //     //     return reject();\n          //     //   }\n          //     // })\n              \n          //     response = await universe.directToSecondViaWebsocket({\n          //       clientId: connectNode.data.clientId,\n          //       RequestNode: inputOpts.RequestNode,\n          //       // method: 'post',\n          //       // url: connectNode.data.connection, // expecting URL at first! \n          //       // body: ExternalRequestNode.data.RequestNode,\n          //       // json: true\n          //     })\n          //     break;\n              \n          //   default:\n          //     console.log('Unable to TalkToSecond when invalid connection type');\n          //     break;\n            \n          // }\n\n          // // ONLY returning a \"second\" response! (no other URL is allowed besides this, for now) \n          // return resolve(response.secondResponse);\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}