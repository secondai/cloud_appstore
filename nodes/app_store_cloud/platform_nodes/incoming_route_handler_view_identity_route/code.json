{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "8a1aec75-e403-4e69-84ad-da2fa3652758",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: View Identity Route (frontend) --');\n      \n      var page = `\n        <!DOCTYPE html>\n        <html>\n          <head>\n            <meta charset=\"utf-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n            <title>Second Identity Route</title>\n            \n            <script src=\"https://cdnjs.cloudflare.com/ajax/libs/stellar-sdk/0.10.3/stellar-sdk.min.js\"></script>\n            <script src=\"https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js\"></script>\n            \n            <script type=\"text/javascript\">\n            \n              function clearAndWrite(v){\n                document.open();\n                document.write(v);\n                document.close();\n              }\n              \n              var horizonPossible = {\n                public: {\n                  name: 'PubNet',\n                  address: 'https://horizon.stellar.org',\n                  network: 'public'\n                },\n                test: {\n                  name: 'TestNet',\n                  address: 'https://horizon-testnet.stellar.org',\n                  network: 'test'\n                }\n              };\n              \n              // load Route\n              // - get rid of \"/html\" or \"/view\"\n              var routeFullPath = window.location.pathname.substring(6); \n              \n              if(routeFullPath.indexOf('test://') === 0){\n                // ok \n              } else if(routeFullPath.indexOf('test:') === 0){\n                // needs fix \n                routeFullPath = [routeFullPath.slice(0, 5), '//', routeFullPath.slice(5)].join('')\n              }\n              if(routeFullPath.indexOf('second://') === 0){\n                // ok \n              } else if(routeFullPath.indexOf('second:') === 0){\n                // needs fix \n                routeFullPath = [routeFullPath.slice(0, 7), '//', routeFullPath.slice(7)].join('')\n              }\n              \n              \n              if(routeFullPath.indexOf('://') === -1){\n                // Missing, default to public \n                routeFullPath = 'second://' + routeFullPath;\n              }\n              \n              var parser = window.document.createElement('a');\n              parser.href = routeFullPath; \n                \n              try {\n                var protocol = parser.protocol;\n                switch(protocol){\n                  case 'id:':\n                  case 'idtest:':\n                  case 'test:':\n                  case 'second:':\n                    parser.protocol = 'http:';\n                    break;\n                  \n                  default:\n                    window.alert('Invalid protocol. please use id:// or idtest:// or second://');\n                    throw \"invalid protocol\"\n                }\n                \n                var baseIdentity = parser.host;\n                var subname = parser.username || '';\n                var password = parser.password.length ? parser.password : '';\n                var routePath = parser.pathname || '/'; // parser.pathname ? parser.pathname.slice(1) : ''; // OLD removed leading slash! \n                \n                console.log('Parsed route:', {baseIdentity, subname, password, routePath});\n              \n                var stellarServer\n              \n                switch(protocol){\n                  case 'id:':\n                  case 'second:':\n                    StellarSdk.Network.usePublicNetwork();\n                    stellarServer = new StellarSdk.Server(horizonPossible['public'].address);\n                    break;\n                  case 'idtest:':\n                  case 'test:':\n                  case 'secondtest:':\n                    StellarSdk.Network.useTestNetwork();\n                    stellarServer = new StellarSdk.Server(horizonPossible['test'].address);\n                    break;\n                  default:\n                    console.error('Invalid protocol');\n                    throw \"invalid protocol\"\n                }\n                \n                console.log('stellarServer', stellarServer);\n                \n                // var usernameSeed = universe.crypto.createHash('sha256').update(baseIdentity).digest(); //returns a buffer\n                var baseIdentity = baseIdentity.normalize('NFKC').toLowerCase();\n                \n                console.log('baseIdentity:', baseIdentity);\n                \n                var usernameSeed = sha256.array(baseIdentity);\n                // NFK\n                console.log('usernameSeed', usernameSeed);\n                \n                var pairForIdentity = StellarSdk.Keypair.fromRawEd25519Seed(usernameSeed);\n                \n                console.log('pairForIdentity', pairForIdentity);\n                \n                clearAndWrite('Loading identity');\n                \n                stellarServer.loadAccount(pairForIdentity.publicKey())\n                .then(function(identityAccount){\n                  \n                  clearAndWrite('Identity loaded');\n                  \n                  console.log('identityAccount:', identityAccount);\n                  \n                  // var lookupPath = subname + '|' + routePath;\n                  // if(password){\n                  //   lookupPath = password + '|' + subname + '|' + routePath;\n                  //   // lookupPath = await encryptToString(subname + '|' + routePath, password+routePath)\n                  // }\n                  // var lookupPath = '/' + routePath;\n                        \n                  // route path ALWAYS starts with a slash \n                  // - reserving non-slash for zone-like files \n                  // if(routePath.length == 0){\n                  //   routePath = '/';\n                  // }\n                  \n                  var tmpQuerystring = window.location.search.substring(1);\n                  var vars = tmpQuerystring.split('&');\n                  var querystring = {};\n                  for (var i = 0; i < vars.length; i++) {\n                    var pair = vars[i].split('=');\n                    querystring[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n                  }\n                  switch(querystring.slash){\n                    case 0:\n                    case '0':\n                    case false:\n                    case 'false':\n                      routePath = routePath.slice(1);\n                      break;\n                    default:\n                      break;\n                  }\n                  switch(querystring.root){\n                    case 1:\n                    case '1':\n                    case true:\n                    case 'true':\n                      routePath = routePath.slice(1);\n                      break;\n                    default:\n                      break;\n                  }\n                  \n                  let lookupPath = baseIdentity + '|' + subname + '|' + password + '|' + routePath;\n                  \n                  // var lookupPathHash = universe.crypto.createHash('sha256').update(lookupPath).digest('hex'); \n                   \n                  console.log('lookupPath:', lookupPath); \n                                   \n                  var lookupPathHash = sha256.create().update(lookupPath).hex();\n                  \n                  console.log('lookupPathHash', lookupPathHash);\n                  \n                  clearAndWrite('Getting stellar value for key: ' + lookupPathHash);\n                  \n                  // get the ipfs value \n                  identityAccount.data({key: lookupPathHash})\n                  .then(function(dataValue) {\n                    console.log('decoded dataValue (base64): ', dataValue); \n                    var decoded = atob(dataValue.value);\n                    return decoded;\n                  })\n                  .then(function(valueIpfsHash){\n                    \n                    console.log('Data Result:', valueIpfsHash);\n                    if(!valueIpfsHash){\n                      clearAndWrite('Error: failed loading key from stellar for path: ' + lookupPath);\n                      throw 'Missing data result'\n                    }\n                    \n                    clearAndWrite('Loading IPFS value for hash: ' + valueIpfsHash);\n                    \n                    // Load IPFS data \n                    console.log('valueIpfsHash:', valueIpfsHash);\n                    \n                    window.fetch('https://ipfs.io/ipfs/' + valueIpfsHash)\n                    .then(function(res){\n                      console.log('from IPFS.io:', res);\n                      return res.text();\n                    })\n                    .then(function(textResult){\n                      clearAndWrite(textResult);\n                    })\n                    .catch(function(){\n                      console.error('Failed loading IPFS hash from ipfs.io');\n                      clearAndWrite('Error: failed loading data from IPFS for hash (https://ipfs.io/ipfs/'+valueIpfsHash+'): ' + valueIpfsHash);\n                    })\n                    \n                  \n                    // var ipfsData = await getIpfsValue(valueIpfsHash);\n                    \n                    // console.log('ipfsData:', ipfsData);\n                    \n                    // var dec = ipfsData;\n                    // var actualValue = dec;\n                    // if(password){\n                    //   console.log('had password'); \n                    //   dec = await decryptToString(ipfsData, password+routePath);\n                    //   console.log('decrypted1:', dec);\n                    //   actualValue = await getIpfsValue(dec);\n                    //   dec = await decryptToString(actualValue, password+routePath);\n                    //   actualValue = dec;\n                    // }\n                    \n                    // console.log('decrypted-same:', dec == actualValue ? true:false, dec, actualValue);\n                    \n                    \n                    // // expecting a Node type to be returned \n                    // var nodeData;\n                    // try {\n                    //   nodeData = JSON.parse(actualValue);\n                    // }catch(err){\n                    //   console.error('unable to parse nodedata');\n                    // }\n                    // // document.write(nodeData);\n                    // document.write(actualValue);\n                    \n                  })\n                  .catch(function (err) {\n                    console.error('ipfs error', err, err.stack);\n                    clearAndWrite('Error: failed loading key from stellar for path: ' + lookupPath);\n                    return null;\n                  })\n                  \n                })\n                .catch(function (err) {\n                  console.error('identity error', err);\n                  clearAndWrite('Error: failed loading identity from stellar: ' + baseIdentity);\n                  return null;\n                })\n                \n                \n              }catch(err){\n                // failed finding route data \n                console.error('Failed search', err);\n                clearAndWrite('Error: FAILED SEARCHING (error in console)');\n              }\n              \n              \n              \n            </script>\n          </head>\n          <body>\n          </body>\n        </html>\n      `;\n\n      await universe.httpResponse('send', page);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}