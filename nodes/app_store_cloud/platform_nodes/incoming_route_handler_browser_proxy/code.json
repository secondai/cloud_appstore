{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "8a1aec75-e403-4e69-84ad-da2fa3652758",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: Browser Proxy (to websocket) --');\n      \n      \n      let page = '';\n      \n      if(INPUT.data.req.method != 'POST'){\n        page = {\n          type: 'error:Qmtesting',\n          data: {\n            msg: 'Expecting POST for pass-thru'\n          }\n        };\n        await universe.httpResponse('send', page);\n        return;\n      }\n      \n      \n      var proxyEndpointId = INPUT.data.req.path.substring(7);\n      \n      console.log('proxyEndpointId', proxyEndpointId);\n      \n      let browserProxies = universe.sharedServices.browserProxies || [];\n\n      let proxyFound = browserProxies.find(item=>{\n        return item.proxyEndpointId == proxyEndpointId;\n      });\n      \n      // Send body to proxy \n      // - respond with result \n      \n      \n      if(!proxyFound){\n        page = {\n          type: 'error:Qmtesting',\n          data: {\n            msg: 'Missing proxy (1)'\n          }\n        };\n        await universe.httpResponse('send', page);\n        \n      } else {\n        \n        // try and send to proxy \n        console.log('sending to proxy1');\n        let socket = proxyFound.socket;\n        // socket.emit\n        \n        // TODO: have a 30 second timeout? \n        // await universe.httpResponse('send', page);\n        \n        // Prevent wipe until after complete \n        let doneCanWipe;\n        universe.wipeFunc = new Promise(resolve=>{\n          doneCanWipe = resolve;\n        });\n        \n        // let linkRequestNode = {\n        //   type: 'testing:Qm123',\n        //   data: true\n        // }\n        \n        let linkRequestNode = INPUT.data.req.body;\n        // {\n        //   type: 'signed_message:Qmtesting',\n        //   data: {\n        //     msgId: universe.uuidv4(), // for uniqueness\n        //     to: 'test1to', // TODO: encrypt for that username too? using a different pubkey? \n        //     from: 'test2from',\n        //     content: {\n        //       type: 'text:Qmtesting',\n        //       data: {\n        //         text: 'testing text'\n        //       }\n        //     },\n        //     sig: undefined,\n        //     // createdAt ? \n        //   }\n        // }\n        \n        console.log('sending to proxy2', typeof linkRequestNode);\n        socket.emit('proxied-request', linkRequestNode, async (ResponseNode)=>{\n          // console.log('Response from server for linkRequestNode (via websocket)', JSON.stringify(ResponseNode,null,2));\n          console.log('Responding via proxied-request emitted to socket', ResponseNode); \n          await universe.httpResponse('send', ResponseNode);\n          \n          doneCanWipe(); // clear \n          \n        });\n        \n      }\n\n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}