{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "8a1aec75-e403-4e69-84ad-da2fa3652758",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: Accept invite code (create account for passphrase)--');\n      \n      // INPUT: expressObj\n      \n      // address for control comes from invite (they generate a password) \n      \n      let page = {\n        type: 'register_result:Qmlf3232f',\n        data: {}\n      };\n      \n      let headers = INPUT.data.req.headers;\n      let body = INPUT.data.req.body;\n      // let query = INPUT.data.req.query;\n\n      // Get inviteCode to download \n      let inviteCode = body.inviteCode;\n      if(!inviteCode){\n        await universe.httpResponse('send', 'Missing inviteCode');\n        return resolve(true);\n      }\n      \n      console.log('inviteCode:', inviteCode);\n      \n      let network = body.network;\n      if(!network){\n        await universe.httpResponse('send','Missing network');\n        return resolve(true);\n      }\n      \n      // Get invite codes (root level) \n      let nodes = await universe.searchMemory({\n        filter: {\n          dataFilter: {\n            nodeId: null,\n            type: 'account_invite:Qm2934872344232324',\n            'data.inviteCode': inviteCode\n          },\n        }\n      });\n      if(!nodes.length){\n        console.error('unable to find inviteCode:', inviteCode);\n        await universe.httpResponse('send', 'Unable to find inviteCode');\n        return resolve(true);\n      }\n      \n      // expecting single! \n      let accountInviteNode = nodes[0];\n      \n      // lock inviteCode node (prevent double-invites?) \n      if(accountInviteNode.data.accepted){\n        await universe.httpResponse('send', 'Invite already accepted');\n        return resolve(true);\n      }\n      \n      // network matches?\n      if(accountInviteNode.data.network != network){\n        await universe.httpResponse('send', 'Network invalid for invite');\n        return resolve(true);\n      }\n      \n      // create a new Passphrase \n      // - this is used for generating the secret source account for the user \n      // - we store the publicKey version (for verification)! \n      \n      // create new Source account using our internal STELLAR_SEED account \n      \n      // page.data.passphrase = passphrase;\n            \n      let StellarSdk = universe.require('stellar-sdk');\n      let crypto = universe.require('crypto');\n\n      let address = body.address;\n      \n      console.log('Address (pubKey):', address); // this is the address they want created (generated using their password) \n      \n      console.log('Network:', network); \n      \n      var pairTarget = StellarSdk.Keypair.fromPublicKey(address);\n\n      \n      let stellarServer;\n      let pairSource;\n      \n      // console.log('STELLAR_NETWORK:', process.env.STELLAR_NETWORK);\n      switch(network){\n        case 'public':\n          StellarSdk.Network.usePublicNetwork();\n          stellarServer = new StellarSdk.Server('https://horizon.stellar.org');\n          pairSource = StellarSdk.Keypair.fromSecret(universe.env.INVITE_STELLAR_SEED_PUBNET);\n          break;\n        case 'test':\n        default:\n          StellarSdk.Network.useTestNetwork();\n          stellarServer = new StellarSdk.Server('https://horizon-testnet.stellar.org');\n          pairSource = StellarSdk.Keypair.fromSecret(universe.env.INVITE_STELLAR_SEED_TESTNET);\n          break;\n      }\n      \n  \n\n      console.log('pkSource Seed:', pairSource.secret());\n      // console.log('pkTarget Seed:', pairTarget.secret()); // dont know this!\n\n\n      // Load Target account\n      let targetAccount = await stellarServer\n      .loadAccount(pairTarget.publicKey())\n      .catch(()=>{\n        return false;\n      })\n\n      if(targetAccount){\n        // target account exists\n        // - unexpected, expecting to use random targetAccount \n        \n        await universe.httpResponse('send', 'Invalid targetAccount, please try again');\n        return resolve(true);\n\n      }\n\n\n      // identity Account doesn't exist \n      // - register account (and setup multisig) if I have a balance in my sourceAccount \n\n\n      // Load source account\n      let sourceAccount;\n      try {\n        sourceAccount = await stellarServer.loadAccount(pairSource.publicKey())\n      }catch(err){\n        // problem with account \n        console.error('acount error:', err.name, err.message); \n        await universe.httpResponse('send', 'Problem with source account, please try again');\n        return resolve(true);\n\n      }\n\n      // get source balance \n      if(sourceAccount){\n        let balance = 0;\n        balance = sourceAccount.balances[0].balance;\n\n        console.log('Balance:', balance);\n\n        balance = parseInt(balance,10);\n        if(balance < 10){\n          console.error('Insufficient balance in account for creation:', sourceAccount.balances[0].balance);\n            \n          await universe.httpResponse('send', 'Insufficient balance in account for creation, please try again');\n          return resolve(true);\n        }\n      }\n\n      // Start building the transaction.\n      let transaction = new StellarSdk.TransactionBuilder(sourceAccount)\n      .addOperation(StellarSdk.Operation.createAccount({\n        destination: pairTarget.publicKey(),\n        startingBalance: \"10.0\"\n        // source: pair\n      }))\n      .build();\n\n      // Sign the transaction to prove you are actually the person sending it.\n      transaction.sign(pairSource); // sourceKeys\n\n      // send to stellar network\n      let stellarResult = await stellarServer.submitTransaction(transaction)\n      .then(function(result) {\n        console.log('Stellar Success createAccount'); // , result); \n        return result;\n      })\n      .catch(function(error) {\n        console.error('Stellar Something went wrong!', error);\n        // If the result is unknown (no response body, timeout etc.) we simply resubmit\n        // already built transaction:\n        // server.submitTransaction(transaction);\n        return null;\n      });\n\n      // console.log('stellarResult', stellarResult);\n      if(!stellarResult){\n        console.error('Failed creating account');\n        \n        await universe.httpResponse('send', 'Failed creating account, please try again');\n        return resolve(true);\n      }\n\n      console.log('Created account! returning passphrase');\n\n      // reload the account \n      console.log('reload account');\n      targetAccount = await stellarServer.loadAccount(pairTarget.publicKey())\n\n      accountInviteNode.data.sourcePublicKey = pairTarget.publicKey();\n      accountInviteNode.data.accepted = true;\n      \n      console.log('updating invite node with accepted=true');\n      await universe.updateNode(accountInviteNode);\n      \n      page.data.success = true;\n      \n      console.log('returning page');\n      await universe.httpResponse('send', page);\n      \n      return resolve(true);\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}