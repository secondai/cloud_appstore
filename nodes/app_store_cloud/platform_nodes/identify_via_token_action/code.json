{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "87889324-ce31-45f8-b80d-4f6d7a39f356",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--identify_via_token_action--');\n      \n      // encrypt_string:0.0.1:local:329fj2938\n      let nodeId;\n      let publicKey;\n      let internalUserId; // for InternalUser \n      let InternalUserNode;\n      let ActAsExternalIdentityNode; // for handling shared_data\n      let tokenNode;\n      let decrypted;\n      let encrypted;\n      \n      let cacheAppId = universe.getParentRoot(SELF)._id;\n      let cache;\n      \n      try {\n        \n          \n        // // Created encrypted token for identification \n        // let tokenDataString = JSON.stringify({\n        //   type: 'identity_token_encrypted:0.0.1:local:8928h9h88832',\n        //   data: {\n        //     internalId: null,\n        //     publicKey: 'learn'\n        //   }\n        // });\n        // // encrypt_string:0.0.1:local:329fj2938\n        // encrypted = await universe.capabilities().encryptPrivate({\n        //   type: 'string',\n        //   data: tokenDataString\n        // });\n        \n        decrypted = await universe.capabilities().decryptPrivate({\n          type: 'string',\n          data: INPUT.data\n        });\n        \n        // console.log('decrypted:', decrypted);\n        \n        // get the local public key from decrypted package (JSON string) \n        if(decrypted.type != 'string:0.0.1:local:289hf329h93'){\n          console.error('Identify_via_token_action error1:', INPUT);\n          return resolve({\n            type: 'boolean:0.0.1:local:98h8fh28h3232f',\n            data: false,\n            extra: {\n              msg: 'Failed decrypting INPUT.data',\n              inputData: INPUT.data ? INPUT.data : 'NO INPUT DATA PROVIDED',\n              INPUT,\n              decrypted,\n              // encrypted,\n            }\n          });\n        }\n        // console.log('Parsing tokenNode1');\n        tokenNode = JSON.parse(decrypted.data);\n        // console.log('Parsing tokenNode2', tokenNode);\n        \n        // console.log('next1');\n        nodeId = tokenNode.data.internalId;\n        // console.log('next2');\n        publicKey = tokenNode.data.publicKey;\n        // console.log('next3');\n        internalUserId = tokenNode.data.internalUserId;\n        // console.log('next4');\n        // todo: expiresAt (force re-auth)\n      }catch(err){\n        console.error('Identify_via_token_action error2:', err);\n        return resolve({\n          type: 'boolean:0.0.1:local:98h8fh28h3232f',\n          data: false,\n          extra: {\n            INPUT,\n            decrypted,\n            // encrypted,\n            verified: false,\n            err: true,\n            errStr: err.toString()\n          }\n        });\n      }\n      \n      // create some default ExternalIdentityNodes for certain private keys \n      // - \"learning\" for example\n      let ExternalIdentityNode;\n      \n      switch(publicKey){\n        // case 'learn':\n        //   // allow anyone who was pre-allowed \n            \n        //   ExternalIdentityNode = {\n        //     type: 'external_identity:0.0.1:local:8982f982j92',\n        //     data: {\n        //       roles: ['learn'],\n        //       publicKey\n        //     }\n        //   }\n          \n        //   break;\n        \n        \n        default:\n          // actual publicKey passed in \n          \n          // console.log('Finding ExternalIdentity');\n          \n          // Get local ExternalIdentity if it exists \n          // - should exist, unless we deleted it! \n          cache = ['search-publickey', cacheAppId, publicKey].join('|');\n          let nodes = await universe.searchMemory({\n            cache,\n            reCache: [{\n              event: 'all',\n              dataFilter: {\n                type: {\n                  $like: 'external_identity:'\n                },\n              }\n            }],\n            lean: true,\n            filter: {\n              // responseType: 'cjson',\n              dataFilter: {\n                _id: nodeId,\n                type: {\n                  $like: 'external_identity:'\n                },\n                'data.publicKey' : publicKey\n              },\n              // sqlFilter: {\n              //   _id: nodeId,\n              //   type: 'external_identity:0.0.1:local:8982f982j92',\n              //   data: {\n              //     publicKey: publicKey\n              //   }\n              // },\n              // function for returning data from the Node, after filtering a bit \n              // - includes both the Node, and Nodes with nodeId (pointers) \n              filterNodes: tmpNodes=>{\n                return tmpNodes;\n              }\n            }\n          });\n          \n          if(!nodes || !nodes.length){\n            console.log('No ExternalIdentityNode match for publicKey!');\n            return resolve({\n              type: 'boolean:0.0.1:local:98h8fh28h3232f',\n              data: {\n                missingNode: true,\n                INPUT,\n              }\n            });\n            \n          }\n          \n          ExternalIdentityNode = nodes[0];\n          console.log('Found ExternalIdentityNode for decrypted token');\n          \n          // see if the InternalUser should also be included\n          if(internalUserId){\n            console.log('Finding internalUserId', internalUserId);\n            cache = ['search-internal-user', cacheAppId, internalUserId].join('|');\n            let InternalUserNodes = await universe.searchMemory({\n              cache,\n              lean: true,\n              filter: {\n                // responseType: 'cjson',\n                sqlFilter: {\n                  _id: internalUserId,\n                  type: 'internal_user:0.0.1:local:98h32',\n                }\n              }\n            });\n            console.log('Finding internalUserId2');\n            if(InternalUserNodes.length){\n              InternalUserNode = InternalUserNodes[0];\n            } else {\n              console.error('Missing as InternalUser');\n            }\n            console.log('Finding MyPrivateIdentity');\n            let MyPrivateIdentity = await universe.loadAndRunCapability('Identity',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'getPrivate',\n                options: {}\n              }\n            });\n            console.log('Finding MyPrivateIdentity2');\n            \n            // Get the ActAsExternalIdentityNode value \n            // - for search_shared_data action \n            // - aka, when I'm requesting my own data...this is an awkward way of doing it \n            //   - how to handle Second-for-multiple-users vs. Second-for-single-user? \n            console.log('Finding ActsAsExternal');\n            cache = ['find-acts-user', cacheAppId, MyPrivateIdentity.data.identity].join('|');\n            let ActAsExternalIdentityNodes = await universe.searchMemory({\n              cache,\n              lean: true,\n              filter: {\n                // responseType: 'cjson',\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    identity: MyPrivateIdentity.data.identity\n                  }\n                }\n              }\n            });\n            console.log('Finding ActsAsExternal2');\n            if(ActAsExternalIdentityNodes.length){\n              ActAsExternalIdentityNode = ActAsExternalIdentityNodes[0];\n            } else {\n              console.error('Missing as ActAsExternalIdentityNode');\n            }\n            \n            \n            \n          } else {\n            console.log('Skipping internalUserId');\n          }\n           \n          break;\n        \n      }\n      \n      \n      // set in request cache \n      // console.error('Setting requestCache:', ExternalIdentityNode._id);\n      await universe.setRequestCacheKeyValue('IdentityNode',ExternalIdentityNode);\n      await universe.setRequestCacheKeyValue('InternalUserNode',InternalUserNode);\n      await universe.setRequestCacheKeyValue('ActAsExternalIdentityNode',ActAsExternalIdentityNode);\n      \n      return resolve({\n        type: 'boolean:0.0.1:local:98h8fh28h3232f',\n        data: true,\n        // ExternalIdentityNode,\n        // decrypted,\n        // internalUserId,\n        // InternalUserNode\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}