{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "c56a8782-0c59-4885-9e11-40bd146e9895",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n \n      let cacheAppId = universe.getParentRoot(SELF)._id;\n      let cache;\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        case 'actionPermissions':\n          \n          // checking permissions for an action \n          // - supplied by action (who is allowed to access) \n          \n          console.log('GROUP from inputOpts:', inputOpts);\n          \n          // Get the Auth'd user \n          // - required! \n          // - otherwise use the internal user? \n          // console.log('Authd user:', JSON.stringify(requestCache.keyvalue.IdentityNode,null,2));\n          // console.log('Authd user2:', JSON.stringify(requestCache.keyvalue.ActAsExternalIdentityNode,null,2));\n          // get ExternalIdentityNode of whoever is requesting the data \n          // - if InternalUserNode, then change to my external_identity_node (should have \"connected\" to myself) \n          //   - not sure if this is the best way to do this \"me vs. others requesting\" thing...\n          let requestCache = await universe.getRequestCache({});\n          let AuthIdentityNode = requestCache.keyvalue.IdentityNode; \n          if(requestCache.keyvalue.ActAsExternalIdentityNode){\n            // Find external_identity_node for this Second \n            // - \"acting as\" \n            AuthIdentityNode = requestCache.keyvalue.ActAsExternalIdentityNode;\n            // - TODO: what about passing in tokens? \n            // - TODO: internal-user permissions (multiple internal users, when Second-as-single-brain-for-company-no-syndication) \n          }\n          \n          let InternalUserNode = requestCache.keyvalue.InternalUserNode;\n          if(!AuthIdentityNode){\n            console.error('Missing AuthIdentityNode');\n            return resolve({\n              type: 'boolean:...',\n              data: false\n            });\n          }\n          \n          // Internal identity making request? \n          // - TODO: clean all this mess up... private/external/internal/etc. \n          let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n          let MyPrivateExternalIdentity;\n          let MyPrivateExternalIdentities = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                nodeId: null,\n                type: 'external_identity:0.0.1:local:8982f982j92',\n                data: {\n                  identity: MyPrivateIdentity.data.identity\n                }\n              }\n            }\n          });\n          if(MyPrivateExternalIdentities.length){\n            MyPrivateExternalIdentity = MyPrivateExternalIdentities[0];\n          } else {\n            console.error('Missing internal MyPrivateExternalIdentity');\n            return resolve({\n              type: 'boolean:...',\n              data: false\n            });\n          }\n          \n          \n          // ONLY returning a \"boolean\" response \n          return resolve({\n            type: 'boolean:...',\n            data: true\n          });\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}