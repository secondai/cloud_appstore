{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // return resolve({\n      //   SEARCHING: 'seraching internal datasource!',\n      //   INPUT,\n      //   SELF\n      // });\n      \n      // schema/format of INPUT data: shared_data_request:Qmsdfljsdj\n      \n      console.log('Search Shared Nodes');\n      \n      // console.log('Testing Syndication!');\n      // let SyndicatedResult = await universe.loadAndRunCapability('Syndicate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'permissions', // or 'single' (with corresponding options) if syndicating a single new piece of data \n      //     options: {\n            \n      //     }\n      //   }\n      // });\n      // return resolve({\n      //   type: '',\n      //   data: []\n      // });\n      \n      \n      // await universe.historyLog({INPUT}, 'searching-internal-datasource', 'debug')\n      \n      // When searching: (permissions) \n      // - search is coming from an external_identity (always!!!) \n      // - search shared_nodes \n      // - for each shared_node, run the signer's identity_attributes_builder \n      //   - INPUT is the search external_identity node, OUTPUT should be a build_identity_attributes \n      //     - \"if in group X, then build_identity_attributes.data.group.uuid = true\" \n      // - run permissions attached to each shared_node, INPUT includes the identity with attributes node, shared_node \n      \n      // syndicated data is also included in shared data! \n      // - aka, data that I didnt create \n      \n      let startTime = (new Date()).getTime();\n      \n      let vmFuncCount = 0;\n      \n      let requestCache = await universe.getRequestCache({});\n      \n      // Get the Auth'd user \n      // - required! \n      // - otherwise use the internal user? \n      // console.log('Authd user:', JSON.stringify(requestCache.keyvalue.IdentityNode,null,2));\n      // console.log('Authd user2:', JSON.stringify(requestCache.keyvalue.ActAsExternalIdentityNode,null,2));\n      // get ExternalIdentityNode of whoever is requesting the data \n      // - if InternalUserNode, then change to my external_identity_node (should have \"connected\" to myself) \n      //   - not sure if this is the best way to do this \"me vs. others requesting\" thing...\n      let AuthIdentityNode = requestCache.keyvalue.IdentityNode; \n      if(requestCache.keyvalue.ActAsExternalIdentityNode){\n        // Find external_identity_node for this Second \n        // - \"acting as\" \n        AuthIdentityNode = requestCache.keyvalue.ActAsExternalIdentityNode;\n        // - TODO: what about passing in tokens? \n        // - TODO: internal-user permissions (multiple internal users, when Second-as-single-brain-for-company-no-syndication) \n      }\n      \n      let InternalUserNode = requestCache.keyvalue.InternalUserNode;\n      \n      if(!AuthIdentityNode){\n        console.error('Missing AuthIdentityNode');\n        return resolve({\n          error: true,\n          message: 'Missing AuthIdentityNode, expecting from identify_via_token'\n        });\n      }\n      \n      // Internal identity making request? \n      // - TODO: clean all this mess up... private/external/internal/etc. \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let MyPrivateExternalIdentity;\n      let MyPrivateExternalIdentities = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            nodeId: null,\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              identity: MyPrivateIdentity.data.identity\n            }\n          }\n        }\n      });\n      if(MyPrivateExternalIdentities.length){\n        MyPrivateExternalIdentity = MyPrivateExternalIdentities[0];\n      } else {\n        throw 'Missing internal MyPrivateExternalIdentity';\n      }\n      \n      \n      console.log('AuthIdentityNode to use for requesting sharedData', JSON.stringify(AuthIdentityNode,null,2));\n      \n      // regex for replacement: (?<=\\[\\[\\$\\$)(.*)(?=\\$\\$\\]\\])\n      // console.log('INPUT.data:', INPUT);\n      let dataFilter = INPUT.data.dataFilter || {}; \n      if(dataFilter){\n        // stringify and replace (temporary way of doing this) \n        dataFilter = JSON.stringify(dataFilter || '',null,2); // required to \"null,2\" for separate lines. this is temporary...\n        console.log('compiling template');\n        try {\n          let compiledDataFilterTemplate = universe.lodash.template(dataFilter, {\n            imports: {\n              $: JSON.stringify\n            },\n            interpolate: /\\\"\\[\\[\\$([\\s\\S]+?)\\$\\$\\]\\]\\\"/g \n            // notice it is missing a $ on the left side (imports variable, for stringifying automatically)! \n          });\n          dataFilter = compiledDataFilterTemplate({\n            INPUT: {\n              data: {\n                requestCache,\n                // NOT including any INPUT.data.inputNode info here! \n              }\n            }\n          });\n          compiledDataFilterTemplate = null;\n        }catch(err){\n          console.error('Failed dataFilter:', err);\n          return false;\n        }\n        \n        console.log('dataFilter:', dataFilter);\n        try {\n          dataFilter = JSON.parse(dataFilter);\n        }catch(err){\n          console.error('Failed parsing dataFilter as JSON object', err);\n          return false;\n        }\n      }\n      \n      \n      // find shared_nodes that match the search \n      // - TODO: improve/optimize searching \n      // console.log('Searching internal datasource1');\n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            // // type: NODE.type,\n            // nodeId: null,\n            nodeId: null,\n            type: 'shared_node:Qmsdfjsdlfsj',\n            active: true,\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure) \n            \n            // action_pointer:0.0.1:local:238972ncr\n            \n            // return new Promise((resolve, reject)=>{\n            //   // if(x==1){\n            //   //   resolve([{type:'FAKE'}]);\n            //   // }\n              \n            //   resolve(tmpNodes);\n            // });\n            \n            // apply datafilter \n            console.log('tmpNodes:', tmpNodes.length, typeof dataFilter);\n            return universe.lodash.query(tmpNodes, dataFilter);\n          },\n        }\n      });\n      // console.log('Searching internal datasource2');\n      \n      \n      let memoryTime = (new Date()).getTime();\n      \n      let workGroup = (new Date()).getTime().toString(); // use this for concurrency\n      \n      \n      // Get all signers from nodes that matched \n      let signerIdentities = universe.lodash.uniq(nodes.map(n=>n.data.signer));\n      \n      console.log('signer identities:', signerIdentities);\n      \n      // build identity_attributes for each signer \n      // - responsibility of external_identity to include the permissions builder when syndicating \n      let externalSignerIdentities = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            // nodeId: null,\n            nodeId: null,\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            // type: 'identity_attributes_builder:Qmdsflj2301113',\n            // data: {\n            //   identity: {\n            //     $in: signerIdentities\n            //   }\n            // },\n            active: true,\n          },\n          filterNodes: tmpNodes=>{\n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                return signerIdentities.indexOf(tmpNode.data.identity) > -1\n              });\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      console.log('externalSignerIdentities:', externalSignerIdentities.length);\n      \n      // iterate over identity_attributes_builder nodes\n      let signers = {};\n      externalSignerIdentities.forEach(signerExternalNode=>{\n        // identity_attributes_builder.data.rules = [{match(obj), apply(obj.assign)}]\n        \n        // Expecting only 1 external_identity for each signer! \n        // - multiple would break things \n        \n        // signers[signerExternalNode.data.identity] = signerExternalNode;\n        \n        let attributesData = {};\n        \n        // let attributesNode = {\n        //   type: 'identity_attributes:Qmdslfkjoi23f88f',\n        //   data: {}\n        // };\n        \n        let foundBuilderNode = signerExternalNode.nodes.find(n=>{\n          return n.type.indexOf('identity_attributes_builder:') === 0;\n        });\n        if(!foundBuilderNode){\n          console.error('Missing identity_attributes_builder node for signer (skipping return?):', signerExternalNode.data.identity);\n        } else {\n          // handle rules \n          // console.log('Found identity_attributes_builder. rules:', foundBuilderNode.data.rules.length);\n          for(let rule of foundBuilderNode.data.rules){\n            // check match of external_identity node, apply \n            // console.log('rule.match:', rule.match);\n            let matches = universe.lodash.query([{\n              type: 'external_identity:0.0.1:local:8982f982j92',\n              data: {\n                identity: AuthIdentityNode.data.identity\n              },\n              nodes: [\n                InternalUserNode,\n                {\n                  type: 'internal_attributes:Qmsdfklj2f0', // TODO: apply attributes using internal Second (score, reputation, etc.)\n                  data: {}\n                },{\n                  type: 'identity_attributes:Qmdslfkjoi23f88f', // TODO: apply attributes using internal Second (score, reputation, etc.)\n                  data: attributesData\n                }\n              ]\n            }], JSON.parse(rule.match)); // JSON-stringified for handling dot-notation and regex across IPC \n            if(matches && matches.length){\n              // apply using object.assign \n               attributesData = Object.assign(attributesData, rule.apply);\n            } else {\n              console.log('NOT ALLOWING:', rule.apply);\n              console.log('AuthIdentityNode:', AuthIdentityNode.data.identity);\n              console.log('DID NOT MATCH:', rule.match);\n            }\n          }\n        }\n        \n        // final node to check against permissions \n        signers[signerExternalNode.data.identity] = {\n          type: 'external_identity:0.0.1:local:8982f982j92',\n          data: {\n            identity: signerExternalNode.data.identity\n          },\n          nodes: [\n            InternalUserNode,\n            {\n              type: 'internal_attributes:Qmsdfklj2f0', // TODO: apply attributes using internal Second (score, reputation, etc.)\n              data: {}\n            },{\n              type: 'identity_attributes:Qmdslfkjoi23f88f', //attributes from signer permissions builder \n              data: attributesData\n            } // TODO: external_identity-supplied values (token, etc.) \n          ]\n        }\n        \n      })\n      \n      console.log('Signers:', JSON.stringify(signers,null,2));\n      \n      \n      // check permissions of each shared_node \n      // - passing in the node, and permissions to be evaluated \n      \n      \n      // await universe.historyLog({INPUT}, 'searching-internal-datasource3 (got return nodes)', 'debug')\n    \n      \n      // console.log('vmFuncCountSetup:', vmFuncCount);\n    \n      // after we determine what a user is allowed to see...\n      // - manipulate === see !! (dont pretend that keeping things hidden here prevents what a user can output) \n      // - could easily say \"match Nodes that have X\" and even though we hide X, they know it exists cuz the ParentNode comes back \n      \n      // pass resulting Node to user's provided MatchFunction to see if this is a Node they want returned \n      // - their function also handles the amount of data they want to receive (any Children, etc.) \n      // - returning undefined means they DO NOT want it included \n      \n      let middleTime = (new Date()).getTime();\n      \n      // get-get requestCache \n      requestCache = await universe.getRequestCache({});\n                                    \n      let finalReturnNodes = [];\n      for(let node of nodes){\n        \n        // Check permissions \n        // // the \"pretty\" version gets converted to a more-anonymized version (uuids, instead of names) \n        // let permissionsNode = {\n        //   type: 'syndication_permissions:Qmsdfkjsl2fj9vxc', // \"pretty\" version\n        //   data: {\n        //     rules: [{\n        //       type: 'allow_group:Qmsfkdljodsnkv',\n        //       data: {\n        //         groupKey: postGroupNodeId\n        //       }\n        //     }]\n        //   }\n        // };\n        // // gets turned into \"ugly\" when syndicating \n        // {\n        //   type: 'syndication_permissions_ugly:Qm2398h9sdhfcbvc23',\n        //   data: {\n        //     rules: [{\n        //       type: 'lodash_query:Qmsdfj902932',\n        //       data: {\n        //         lodashQueryHere...\n        //       }\n        //     }]\n        //   }\n        // }\n        let permissionsNode = node.nodes.find(n=>{\n          return n.type.indexOf('syndication_permissions_ugly:') === 0;\n        });\n        if(!permissionsNode){\n          console.log('Missing syndication_permissions_ugly for shared_node');\n          continue;\n        }\n        \n        console.log('FOUND syndication_permissions_ugly!!');\n        \n        // test permissions \n        let allow = false;\n        for(let uglyRule of permissionsNode.data.rules){\n          // only allowing the \"[uuid-here]:boolean\" schema \n          if(uglyRule.type.indexOf('lodash_query') !== 0){\n            console.error('Invalid uglyRule type, only lodash_query is allowed. tried:', uglyRule.type);\n            continue;\n          }\n          \n          // Check identity permissions \n          // - TODO: could also check data attribute for permissions (is embargo'd)? \n          let matchAgainst = {\n            data: {\n              Identity: signers[node.data.signer],\n              Node: node\n            }\n          };\n          // console.log('matchAgainst', JSON.stringify(matchAgainst, null, 2));\n          // console.log('Tested:', JSON.stringify(JSON.parse(uglyRule.data),null,2));\n          // let tmp1 = {\n          //   'data.Identity.nodes': {\n          //     \"$elemMatch\": {\n          //     \"type\": \"identity_attributes:Qmdslfkjoi23f88f\",\n          //     \"data.58d2edc3-6955-48b5-b14e-7d8ebcaee4b4\": true\n          //     }\n          //   }\n          // };\n          // console.log('Tested2', JSON.stringify(tmp1,null,2));\n          // let matched = universe.lodash.query([matchAgainst], tmp1).length;\n          \n          let matched = universe.lodash.query([matchAgainst], JSON.parse(uglyRule.data)).length // TODO: JSON.stringified uglyRule.data to handle $regex across IPC \n          if(matched){\n            allow = true;\n          } else {\n            allow = false;\n            \n            // check if mine \n            if(MyPrivateIdentity.data.identity == matchAgainst.data.Identity.data.identity){\n              allow = true;\n              console.log('Overwriting ALLOW for internal private user');\n            }\n            \n          }\n          \n        }\n        \n        if(allow){\n          console.log('Allowed!');\n          finalReturnNodes.push(node);\n        } else {\n          console.log('NOT Allowed');\n        }\n        \n        \n      }\n      \n      \n      let endTime = (new Date()).getTime();\n      \n//         universe.console.log(`\n// Internal Search Times: \n// total: ${(endTime - startTime)/1000}\n// searchMemorySetup: ${(memoryTime - startTime)/1000}\n// internalSetup: (${nodes.length}) ${(middleTime - memoryTime)/1000}\n// userFuncs: (${returnNodes.length}) ${(endTime - middleTime)/1000}\n// vmFuncCount: ${vmFuncCount}\n//         `);\n\n      // add to request index (for reduce steps) \n      let requestIndex = INPUT.requestIndex;\n      // console.log('-=-=-=requestIndex:', requestIndex);\n      await universe.setRequestCacheKeyValue('request' + requestIndex, finalReturnNodes);\n          \n      resolve({\n        type: 'list_of_nodes:0.0.1:local:3289f2',\n        data: finalReturnNodes\n      });\n      \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "7090f3d5-3b0b-4c8f-9e44-c01ebf7da87f"
  }
}