{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "6b8419f4-542b-4f17-acc2-ecf7a6288352",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('--incoming_route_handler: Second /ai default node handler--');\n      \n      // INPUT.type = 'express_obj' OR 'socketio_obj' \n      // INPUT.data = {req, res, params} // params is for matched route already \n      \n      // await universe.sleep(10 * 1000);\n      \n      // Get body of input (node) \n      let body;\n      try {\n        // express_obj\n        body = INPUT.data.req.body;\n      }catch(err){\n        try {\n          // socketio object\n          body = INPUT.data.body; \n        }catch(err2){\n          console.error('Failed finding body for req or .body', 'INPUT:', INPUT);\n        }\n      }\n      \n      // console.log('body:', typeof body, body);\n\n      let cacheAppId = universe.getParentRoot(SELF)._id;\n      let cache = ['incoming_web_request_route_second_default_actions', cacheAppId, body.type].join('|');\n      \n      // app root-level (old: global-root) \n      let nodes = await universe.searchMemory({\n        cache,\n        filter: {\n          // sqlFilter: {\n          //   // nodeId: null // OLD: root-level\n          //   // type: INPUT.type,\n          // },\n          dataFilter: {\n            type: {\n              $like: 'incoming_query_function'\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            // this runs isolated, outside of the above context? (not sure..think it is same context though [using INPUT.data.type in search]) \n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                // see if has a ChildNode matching a type \n                let foundMatcherChild = universe.lodash.find(tmpNode.nodes || [],tmpChildNode=>{\n                  return tmpChildNode.type.split(':')[0] == 'incoming_query_type_matcher';\n                })\n                // 'run_action:0.0.1:local:2398y294c23'\n                if(!foundMatcherChild){\n                  return false;\n                }\n                \n                // check match of parent heirarchy \n                // - same app_base as the \"incoming_from_universe\" code INPUT node \n                // - same platform_nodes (going \"cross-platform\" isn't expected, \"app\" may contain multiple platforms [browser, cloud, etc]) \n                // - todo: put into a specific \"directory\" or nodelist\n                \n                \n                \n                if(foundMatcherChild.data.typeMatch != body.type){\n                  return false;\n                }\n                \n                \n                // if(tmpNode.parent){\n                //   return false;\n                // }\n              \n                if(!universe.sameAppPlatform(SELF, tmpNode)){\n                  // console.log('FOUND IT UNDER SAME APP!!!!!', tmpNode._id);\n                  return false;\n                }\n                \n                return true;\n                \n              });\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      // return resolve({\n      //   nodes: nodes.length\n      // });\n      \n      \n      if(nodes.length === 1){\n        // found Node to run for action! \n\n        let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n        \n        // run in vm, and pass in the inputSchema Node! \n        // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n        let actionResult;\n        try {\n          actionResult = await universe.runNodeCodeInVM({\n            codeNode, // includes type/schemaName and data \n            dataNode: body, // should be another Node that can be used by the action! \n            timeout: 15 * 1000\n          });\n        }catch(err){\n          return resolve('FAILED code from incoming_route_handler_second');\n        }\n        \n        // validate actionResult!\n        // - todo\n        \n        // console.log('universe.httpResponse testing');\n        try {\n          universe.httpResponse('send', {\n            secondResponse: {\n              type: 'output_generic:0.0.1:local:239f2382fj2983f',\n              data: actionResult\n            }\n          });\n        }catch(err){\n          console.error('Failed res.send testing', err);\n        }\n        \n        // console.log('INPUT.data.res.send OK!'); // send via expressObj \n        \n        return resolve(actionResult);\n        // { \n        //   txt: 'Response:', \n        //   nodeTypes: nodes.map(n=>n.type),\n        //   actionResult\n        // }); // + result);\n        \n      } else {\n        // no Node found for handling action :( \n        if(nodes.length > 0){\n          return resolve({ \n            error: 'Too many matches for Nodes for action in incoming_from_universe (incoming_web_request)',\n            length: nodes.length,\n            INPUT\n          }); // + result);\n        }\n        return resolve({ \n          error: 'No Nodes for action in incoming_from_universe (incoming_web_request)',\n          INPUT\n        }); // + result);\n      }\n      \n  \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}