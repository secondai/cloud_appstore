{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "90bd3427-5301-415d-ac12-c3f9a3c530d0",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // heartbeat manager (scheduler) \n      // - \"watches\" for changes to heartbeat nodes, updates cron jobs accordingly (adds, removes, etc.) \n      let Cron = universe.require('cron');\n      \n      let cacheAppId = universe.getParentRoot(SELF)._id;\n      let cache;\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      \n      async function findTasks(){\n        // get tasks to watch and run  \n        \n        // app root-level (old: global-root) \n        let heartbeatNodes = await universe.searchMemory({\n          // cache: ['scheduler-tasks', cacheAppId].join('|'),\n          filter: {\n            sqlFilter: {\n              // nodeId: null // OLD: root-level\n              type: 'heartbeat_task:Qmsfj032fjslfdk'\n            }\n          }\n        });\n        \n        // console.log('Total Heartbeat Nodes:', heartbeatNodes.length);\n        \n        return heartbeatNodes;\n        \n      }\n      \n      switch(inputAction){\n        case 'start':\n          \n          // startup manager \n          // - expecting to only start once! \n          console.log('Starting Scheduler (heartbeat manager)');\n              \n          // return resolve({\n          //   type: 'boolean:...',\n          //   data: true\n          // });\n          \n          // heartbeat\n          let idsToWatchForUpdates = [];\n          \n          async function updateRunningTasks(){\n              \n            idsToWatchForUpdates = [];\n            let tasks = await findTasks();\n            \n            console.log('Total Tasks for Scheduler:', tasks.length);\n            \n            // clear any existing \n            universe.globalCache.heartbeatJobs = universe.globalCache.heartbeatJobs || {};\n            Object.keys(universe.globalCache.heartbeatJobs).forEach(taskId=>{\n              // console.log('=-=-=Stopping running job, restarting probably');\n              universe.globalCache.heartbeatJobs[taskId].stop();\n            })\n            \n            // Start cron job for each task \n            // - by ID of heartbeat node \n            let jobs = {};\n            for(let task of tasks){\n              if(!task.data.cron){\n                console.error('Missing task.data.cron!');\n                continue;\n              }\n              \n              // console.log('Starting CronJob for task');\n              \n              try {\n                \n                // console.log('Running CodeNode for heartbeat1!');\n                let codeNode = universe.lodash.find(task.nodes,{type:'code:0.0.1:local:32498h32f2'});\n                \n                idsToWatchForUpdates.push(task._id);\n                idsToWatchForUpdates.push(codeNode._id);\n                \n                var job = new Cron.CronJob(task.data.cron, async function() {\n                  \n                    // console.log('Running CodeNode for heartbeat'); //, codeNode ? true:false);\n                    // let codeNode = universe.lodash.find(task.nodes,{type:'code:0.0.1:local:32498h32f2'});\n                    \n                    // run in vm, and pass in the inputSchema Node! \n                    // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n                    let heartbeatResult;\n                    try {\n                      heartbeatResult = await universe.runNodeCodeInVM({\n                        codeNode, // includes type/schemaName and data \n                        dataNode: {}, // should be another Node that can be used by the action! \n                        timeout: 15 * 1000\n                      });\n                    }catch(err){\n                      return resolve('FAILED code from heartbeatResult');\n                    }\n                    \n                  }, async function () {\n                    /* This function is executed when the job stops */\n                    \n                  },\n                  true, /* Start the job right now */\n                  // timeZone /* Time zone of this job. */\n                );\n                jobs[task._id] = job;\n              }catch(err){\n                console.error('Invalid CRON pattern?', task.data.cron, err);\n              }\n              \n            }\n            \n            universe.globalCache.heartbeatJobs = jobs;\n          }\n          \n          updateRunningTasks();\n          \n          // Start listening for changes to heartbeat nodes \n          // - restart listening on changes\n          universe.eventEmitter.on('node.afterUpdate', function _listener(emitData){\n            // updated node is passed is as emitData (use emitData.type, emitData.data, emitData.nodeId, etc. for node contents) \n            // - TODO: only restart certain nodes, if data is updated, etc. \n            \n            // console.log('afterUpdate in scheduler...'); //, idsToWatchForUpdates, JSON.stringify(emitData,null,2));\n            \n            if(idsToWatchForUpdates.indexOf(emitData._id) > -1){\n              // console.log('Updating Running Tasks!');\n              updateRunningTasks();\n            } else {\n              // console.log('No need to update Running Tasks!');\n            }\n            \n          })\n\n          // ONLY returning a \"boolean\" response (no other URL is allowed besides this, for now) \n          return resolve({\n            type: 'boolean:...',\n            data: true\n          });\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}