{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "90bd3427-5301-415d-ac12-c3f9a3c530d0",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // heartbeat manager (scheduler) \n      // - \"watches\" for changes to heartbeat nodes, updates cron jobs accordingly (adds, removes, etc.) \n      let Cron = universe.require('cron');\n      \n      let cacheAppId = universe.getParentRoot(SELF)._id;\n      let cache;\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      \n      async function findTasks(){\n        // get tasks to return \n        \n        // app root-level (old: global-root) \n        let heartbeatNodes = await universe.searchMemory({\n          cache: ['scheduler-tasks', cacheAppId].join('|'),\n          filter: {\n            sqlFilter: {\n              // nodeId: null // OLD: root-level\n              type: 'heartbeat_task:Qmsfj032fjslfdk'\n            }\n          }\n        });\n        \n        console.log('Total Heartbeat Nodes:', heartbeatNodes.length);\n        \n        return heartbeatNodes;\n        \n      }\n      \n      switch(inputAction){\n        case 'start':\n          \n          // startup manager \n          // - expecting to only start once! \n          console.log('Starting heartbeat manager');\n              \n          // heartbeat\n          \n          let tasks = await findTasks();\n          \n          console.log('Total Tasks:', tasks.length);\n          \n          // clear any existing \n          universe.globalCache.heartbeatJobs = universe.globalCache.heartbeatJobs || {};\n          Object.keys(universe.globalCache.heartbeatJobs).forEach(taskId=>{\n            console.log('=-=-=Stopping running job, restarting probably');\n            universe.globalCache.heartbeatJobs[taskId].stop();\n          })\n          \n          // Start cron job for each task \n          // - by ID of heartbeat node \n          let jobs = {};\n          for(let task of tasks){\n            if(!task.data.cron){\n              console.error('Missing task.data.cron!');\n              continue;\n            }\n            \n            console.log('Starting CronJob for task');\n            \n            try {\n              \n              // console.log('Running CodeNode for heartbeat1!');\n              let codeNode = universe.lodash.find(task.nodes,{type:'code:0.0.1:local:32498h32f2'});\n              var job = new Cron.CronJob(task.data.cron, async function() {\n                \n                  console.log('Running CodeNode for heartbeat'); //, codeNode ? true:false);\n                  // let codeNode = universe.lodash.find(task.nodes,{type:'code:0.0.1:local:32498h32f2'});\n                  \n                  // run in vm, and pass in the inputSchema Node! \n                  // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n                  let heartbeatResult;\n                  try {\n                    heartbeatResult = await universe.runNodeCodeInVM({\n                      codeNode, // includes type/schemaName and data \n                      dataNode: {}, // should be another Node that can be used by the action! \n                      timeout: 15 * 1000\n                    });\n                  }catch(err){\n                    return resolve('FAILED code from heartbeatResult');\n                  }\n                  \n                }, async function () {\n                  /* This function is executed when the job stops */\n                  \n                },\n                true, /* Start the job right now */\n                // timeZone /* Time zone of this job. */\n              );\n              jobs[task._id] = job;\n            }catch(err){\n              console.error('Invalid CRON pattern!', task.data.cron);\n            }\n            \n          }\n          \n          universe.globalCache.heartbeatJobs = jobs;\n          \n          // Start listening for changes to heartbeat nodes \n          // - restart listening on changes\n          try {\n            universe.globalCache.SearchFilters[ ['scheduler-tasks', cacheAppId].join('|') ] = null;\n          }catch(err){\n            console.error(err);\n          }\n          \n          // let testCron = new CronTime('* * * * * *');\n          \n      \n          // console.log('Starting task scheduler');\n          // let schedulerInterval = universe.setInterval(()=>{\n            \n          //   console.log('sheduler');\n            \n          //   // testCron\n          //   let nextSend = testCron.sendAt(1);\n          //   console.log('nextSend:', nextSend);\n            \n          // },1000);\n          \n          // universe.setTimeout(()=>{\n          //   console.log('Clearing interval');\n          //   universe.clearInterval(schedulerInterval);\n          // },5000);\n          \n\n          // ONLY returning a \"second\" response! (no other URL is allowed besides this, for now) \n          return resolve({\n            type: 'boolean:...',\n            data: true\n          });\n          \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}