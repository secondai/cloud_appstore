{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "63c8bfa5-289b-4d8b-b8f5-6e8908fd1ac2",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // INPUT: {\n      //   type: 'update_and_syndicate_data:Qmdsfkjsl..',\n      //   data: {\n      //     sharedNode: Node,\n      //     permissionsNode: Node\n      //     syndicateToNode: Node\n      //   }\n      // }\n      \n      // Permission for updating is found on child \n      // - limited to creator only, for now (as InternalUser.data.uuid) \n    \n      let {\n        sharedNode,\n        permissionsNode,\n        syndicateToNode\n      } = INPUT.data;\n      \n    \n      let requestCache = await universe.getRequestCache();\n      \n      let InternalUserNode;\n      try {\n        InternalUserNode = requestCache.keyvalue.InternalUserNode;\n      }catch(err){\n        console.error('Missing InternalUserNode', err);\n      }\n      if(!InternalUserNode){\n        // Forgot to identify_via_token beforehand \n        console.error('Missing InternalUserNode for create_and_syndicate action');\n        throw \"Missing InternalUserNode for create_and_syndicate action\";\n        return false;\n      }\n      \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      \n      // Get the internal shared node \n      // - checks write permissions also \n      \n      // regex for replacement: (?<=\\[\\[\\$\\$)(.*)(?=\\$\\$\\]\\])\n      // console.log('INPUT.data:', INPUT);\n      \n      \n      // find shared_nodes that match the search \n      // - TODO: improve/optimize searching \n      // console.log('Searching internal datasource1');\n      \n      let t01 = Date.now();\n      let nodes = await universe.searchMemoryByIds({\n        filter: {\n          _ids: [sharedNode._id]\n        }\n      });\n      console.log('SEARCH1 TIME:', (Date.now() - t01)/1000);\n      console.log('Found NODE:', JSON.stringify(nodes,null,2));\n      \n      // return resolve({\n      //   // savedNode\n      //   type: 'error:..',\n      //   data: {\n      //     msg: 'Failed update_and_syndicate',\n      //     INPUT,\n      //     error: true\n      //   }\n      // });\n      \n      \n      \n      // expecting a single result \n      if(nodes.length != 1){\n        console.error('Invalid nodes.length for updating shared_node');\n        return resolve({\n        // savedNode\n          type: 'error:..',\n          data: {\n            msg: 'Failed update_and_syndicate',\n            INPUT,\n            error: true\n          }\n        });\n      }\n      \n      let nodeToUpdate = nodes[0];\n      \n      \n      // Get all signers from nodes that matched \n      let signerIdentities = universe.lodash.uniq(nodes.map(n=>n.data.signer));\n      \n      // console.log('signer identities:', signerIdentities);\n      \n      // build identity_attributes for each signer \n      // - responsibility of external_identity to include the permissions builder when syndicating \n      let cacheAppId = universe.getParentRoot(SELF)._id;\n      let cache = ['externalSignerIdentities', cacheAppId].join('|');\n      let externalSignerIdentities = await universe.searchMemory({\n        cache,\n        filter: {\n          sqlFilter: {\n            // nodeId: null,\n            nodeId: null,\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            // type: 'identity_attributes_builder:Qmdsflj2301113',\n            // data: {\n            //   identity: {\n            //     $in: signerIdentities\n            //   }\n            // },\n            active: true,\n          },\n          filterNodes: tmpNodes=>{\n            return new Promise((resolve, reject)=>{\n              tmpNodes = tmpNodes.filter(tmpNode=>{\n                return signerIdentities.indexOf(tmpNode.data.identity) > -1\n              });\n              resolve(tmpNodes);\n            });\n          },\n        }\n      });\n      \n      // console.log('externalSignerIdentities:', externalSignerIdentities.length);\n      \n      // iterate over identity_attributes_builder nodes\n      let signers = {};\n      externalSignerIdentities.forEach(signerExternalNode=>{\n        // identity_attributes_builder.data.rules = [{match(obj), apply(obj.assign)}]\n        \n        // Expecting only 1 external_identity for each signer! \n        // - multiple would break things \n        \n        // signers[signerExternalNode.data.identity] = signerExternalNode;\n        \n        let attributesData = {};\n        \n        // let attributesNode = {\n        //   type: 'identity_attributes:Qmdslfkjoi23f88f',\n        //   data: {}\n        // };\n        \n        let foundBuilderNode = signerExternalNode.nodes.find(n=>{\n          return n.type.indexOf('identity_attributes_builder:') === 0;\n        });\n        if(!foundBuilderNode){\n          console.error('Missing identity_attributes_builder node for signer:', signerExternalNode.data.identity);\n        } else {\n          // handle rules \n          // console.log('Found identity_attributes_builder. rules:', foundBuilderNode.data.rules.length);\n          for(let rule of foundBuilderNode.data.rules){\n            // check match of external_identity node, apply \n            // console.log('rule.match:', rule.match);\n            let matches = universe.lodash.query([{\n              type: 'external_identity:0.0.1:local:8982f982j92',\n              data: {\n                identity: AuthIdentityNode.data.identity\n              },\n              nodes: [\n                InternalUserNode,\n                {\n                  type: 'internal_attributes:Qmsdfklj2f0', // TODO: apply attributes using internal Second (score, reputation, etc.)\n                  data: {}\n                },{\n                  type: 'identity_attributes:Qmdslfkjoi23f88f', // TODO: apply attributes using internal Second (score, reputation, etc.)\n                  data: attributesData\n                }\n              ]\n            }], JSON.parse(rule.match)); // JSON-stringified for handling dot-notation and regex across IPC \n            if(matches && matches.length){\n              // apply using object.assign \n               attributesData = Object.assign(attributesData, rule.apply);\n            } else {\n              // console.log('NOT ALLOWING:', rule.apply);\n              // console.log('AuthIdentityNode:', AuthIdentityNode.data.identity);\n              // console.log('DID NOT MATCH:', rule.match);\n            }\n          }\n        }\n        \n        // final node to check against permissions \n        signers[signerExternalNode.data.identity] = {\n          type: 'external_identity:0.0.1:local:8982f982j92',\n          data: {\n            identity: signerExternalNode.data.identity\n          },\n          nodes: [\n            InternalUserNode,\n            {\n              type: 'internal_attributes:Qmsdfklj2f0', // TODO: apply attributes using internal Second (score, reputation, etc.)\n              data: {}\n            },{\n              type: 'identity_attributes:Qmdslfkjoi23f88f', //attributes from signer permissions builder \n              data: attributesData\n            } // TODO: external_identity-supplied values (token, etc.) \n          ]\n        }\n        \n      })\n      \n      // console.log('Signers:', JSON.stringify(signers,null,2));\n      \n      \n      // check permissions of each shared_node \n      // - passing in the node, and permissions to be evaluated \n      \n      \n      // await universe.historyLog({INPUT}, 'searching-internal-datasource3 (got return nodes)', 'debug')\n    \n      \n      // console.log('vmFuncCountSetup:', vmFuncCount);\n    \n      // after we determine what a user is allowed to see...\n      // - manipulate === see !! (dont pretend that keeping things hidden here prevents what a user can output) \n      // - could easily say \"match Nodes that have X\" and even though we hide X, they know it exists cuz the ParentNode comes back \n      \n      // pass resulting Node to user's provided MatchFunction to see if this is a Node they want returned \n      // - their function also handles the amount of data they want to receive (any Children, etc.) \n      // - returning undefined means they DO NOT want it included \n      \n      \n      // // re-get requestCache? \n      // requestCache = await universe.getRequestCache({});\n      \n      // Check permissions \n      // // the \"pretty\" version gets converted to a more-anonymized version (uuids, instead of names) \n      // let permissionsNode = {\n      //   type: 'syndication_permissions:Qmsdfkjsl2fj9vxc', // \"pretty\" version\n      //   data: {\n      //     rules: [{\n      //       type: 'allow_group:Qmsfkdljodsnkv',\n      //       data: {\n      //         groupKey: postGroupNodeId\n      //       }\n      //     }]\n      //   }\n      // };\n      // // gets turned into \"ugly\" when syndicating \n      // {\n      //   type: 'syndication_permissions_ugly:Qm2398h9sdhfcbvc23',\n      //   data: {\n      //     rules: [{\n      //       type: 'lodash_query:Qmsdfj902932',\n      //       data: {\n      //         lodashQueryHere...\n      //       }\n      //     }]\n      //   }\n      // }\n      let checkPermissionsNode = nodeToUpdate.nodes.find(n=>{\n        return n.type.indexOf('write_permissions_ugly:') === 0;\n      });\n      if(!checkPermissionsNode){\n        console.error('Missing write_permissions_ugly for shared_node');\n        return resolve({\n        // savedNode\n          type: 'error:..',\n          data: {\n            msg: 'Failed update_and_syndicate',\n            INPUT,\n            error: true\n          }\n        });\n      }\n      \n      // console.log('FOUND write_permissions_ugly!!');\n      \n      // test permissions \n      let allow = false;\n      for(let uglyRule of checkPermissionsNode.data.rules){\n        // only allowing the \"[uuid-here]:boolean\" schema \n        if(uglyRule.type.indexOf('lodash_query') !== 0){\n          console.error('Invalid uglyRule type, only lodash_query is allowed. tried:', uglyRule.type);\n          continue;\n        }\n        \n        // Check identity permissions \n        // - TODO: could also check data attribute for permissions (is embargo'd)? \n        let matchAgainst = {\n          data: {\n            Identity: signers[nodeToUpdate.data.signer],\n            Node: nodeToUpdate\n          }\n        };\n        // console.log('matchAgainst', JSON.stringify(matchAgainst, null, 2));\n        // console.log('Tested:', JSON.stringify(JSON.parse(uglyRule.data),null,2));\n        // let tmp1 = {\n        //   'data.Identity.nodes': {\n        //     \"$elemMatch\": {\n        //     \"type\": \"identity_attributes:Qmdslfkjoi23f88f\",\n        //     \"data.58d2edc3-6955-48b5-b14e-7d8ebcaee4b4\": true\n        //     }\n        //   }\n        // };\n        // console.log('Tested2', JSON.stringify(tmp1,null,2));\n        // let matched = universe.lodash.query([matchAgainst], tmp1).length;\n        \n        let matched = universe.lodash.query([matchAgainst], JSON.parse(uglyRule.data)).length // TODO: JSON.stringified uglyRule.data to handle $regex across IPC \n        if(matched){\n          allow = true;\n        } else {\n          allow = false;\n        }\n        \n      }\n      \n      if(!allow){\n        console.error('Not allowed to update');\n        \n        console.error('Failed permissions for write for updating shared_node');\n        \n        return resolve({\n        // savedNode\n          type: 'error:..',\n          data: {\n            msg: 'Failed update_and_syndicate',\n            INPUT,\n            error: true\n          }\n        });\n        \n      }\n      \n      // console.log('----');\n      // console.log('Allowed to make write changes!!!');\n      // console.log('----');\n      // return resolve({\n      //   // savedNode\n      //   type: 'error:..',\n      //   data: {\n      //     msg: 'Failed update_and_syndicate',\n      //     INPUT,\n      //     error: true\n      //   }\n      // });\n      \n      // Make write changes \n      // - only changing shared_node for now, NOT any of the permissions \n      \n      // sourceId is the path back to the node \n      // - \"type:location\" i.e. \"idtestid:sub@nick:internalIdhere\"\n      // - depends on the identity (public/private,etc.) \n      let sourceType;\n      switch(MyPrivateIdentity.data.identity.split(':')[0]){\n        case 'id':\n          sourceType = 'idid'; // normal public identity, normal internal id, the \"ideal\" situation \n          break;\n        case 'idtest':\n          sourceType = 'idtestid';\n          break;\n        default:\n          // unexpected! \n          console.error('Invalid ID type!, missing id or idtest of MyPrivateNode.data.identity');\n          return false;\n          break;\n      }\n      let sourceId = [sourceType, ':', MyPrivateIdentity.data.identity.split(':')[1], ':', sharedNode._id].join('')\n      let sharedNodeData = {\n        _id: sourceId, // GLOBAL id (\"type\":\"address\"), \"idtestid:sub@nick:internalId\" \n        name: sharedNode.name,\n        type: sharedNode.type,\n        data: sharedNode.data,\n        v: sharedNode.data.v || 1, // version (increment version automatically?) \n        signer: MyPrivateIdentity.data.identity // \"idtest:nick\"\n      }\n      \n      // Sign stringify({_id, type, data})\n      let stringToSign = JSON.stringify(sharedNodeData);\n      let SignedNode = await universe.loadAndRunCapability('rsa',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'sign',\n          options: {\n            stringToSign\n          }\n        }\n      });\n      \n      let result = SignedNode.data; // base64-encoded string signature \n      \n      // Add signature to shared_node.data.signature \n      sharedNodeData.sig = result; // base64-encoded string \n      \n      // // Add permissions node (save whatever was sent in) \n      // // - permissions are checked in action \"search_shared_data\"\n      // //   - the resulting \"syndication_permissions_ugly\" has the matching to use for access requests \n      // // - TODO: verify incoming permissions \n      // // - TODO: internal-user permissions (using external for now?) \n      // let newPermisionsNode = permissionsNode;\n      // if(permissionsNode.type.indexOf('syndication_permissions:') !== 0){\n      //   console.error('Invalid permissionsNode supplied'); \n      //   return false;\n      // } else {\n      //   // Check validity of permissionsNode \n      //   let lodashQueries = [];\n      //   for(let rule of permissionsNode.data.rules){\n      //     let matchObj;\n      //     switch(rule.type.split(':')[0]){\n              \n      //       case 'allow_group':\n                \n      //         matchObj = {\n      //           \"data.Identity.nodes\": {\n      //             $elemMatch: {\n      //               type: 'identity_attributes:Qmdslfkjoi23f88f',\n      //               [\"data.\" + rule.data.groupKey]: true\n      //             }\n      //           }\n      //         };\n      //         lodashQueries.push(matchObj);\n      //         break;\n            \n            \n      //       case 'internal_private': // internal_private:Qm3289f0h23\n            \n      //         console.log('CHECKING internal_private:Qm3289f0h23');\n              \n      //         matchObj = {\n      //           \"data.Identity.nodes\": {\n      //             $elemMatch: {\n      //               type: {\n      //                 $like: 'internal_user:'\n      //               },\n      //               [\"data.uuid\"]: InternalUserNode.data.uuid\n      //             }\n      //           }\n      //         };\n      //         lodashQueries.push(matchObj);\n              \n      //         break;\n            \n            \n      //       default:\n      //         console.error('Invalid permissionsNode rule type (only allow_groups allowed):', rule.type);\n      //         continue;\n      //     }\n      //   }\n        \n      // }\n      \n      // Update type to shared_node \n      // - update entire node locally \n      // savedUpdatedNode.type = 'shared_node:Qmsdfjsdlfsj'; // not \"tmp_shared_node\" anymore \n      delete sharedNode.nodes;\n      console.log('UPDATING NODE:', JSON.stringify(sharedNode,null,2));\n      // savedUpdatedNode.data = sharedNodeData;\n      \n      // return resolve({\n      //   // savedNode\n      //   type: 'error:..',\n      //   data: {\n      //     msg: 'Failed update_and_syndicate',\n      //     INPUT,\n      //     error: true\n      //   }\n      // });\n      \n      let t1 = Date.now();\n      let savedUpdatedNode = await universe.updateNode(sharedNode, true);\n      console.log('UPDATE TIME:', (Date.now() - t1)/1000);\n      \n      \n      // Run syndicateTo (\"push\" sharing) \n      // - TODO: figure out who I'm sharing to (match the \"allow_groups\" rules) \n      // - could have defaults here? \n      // - passed-in idenitities to push to (\"idtest:x@y\") \n      // let SyndicatedResult = await universe.loadAndRunCapability('Syndicate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'everything', // or 'single' (with corresponding options) if syndicating a single new piece of data \n      //     options: {\n            \n      //     }\n      //   }\n      // });\n      \n      // // NOT waiting for syndication to complete!\n      // // - just triggering it \n      // // - TODO: trigger via Job, instead of this way? \n      // console.log('Testing Syndication after adding (single)');\n      // let SyndicatedResult = await universe.loadAndRunCapability('Syndicate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'single', // or 'single' (with corresponding options) if syndicating a single new piece of data \n      //     options: {\n      //       type: 'internal_node_id:Qmsdf23lf09j23',\n      //       data: {\n      //         nodeId: savedUpdatedNode._id\n      //       }\n      //     }\n      //   }\n      // });\n      \n      \n      universe.console.log('--Returning update_and_syndicate--');\n      \n      return resolve(savedUpdatedNode);\n      \n      \n      \n    }catch(err){\n      console.error('FAILED update_and_syndicate',err);\n      \n      return resolve({\n        // savedNode\n        type: 'error:..',\n        data: {\n          msg: 'Failed update_and_syndicate',\n          INPUT,\n          error: true,\n          err: err\n        }\n      });\n      // resolve({ERROR: true, err: err});\n    }\n    \n    \n  })\n})()"
  }
}